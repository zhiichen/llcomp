Index: pycparser/c_lexer.py
===================================================================
--- pycparser/c_lexer.py	(revisiÃ³n: 91)
+++ pycparser/c_lexer.py	(copia de trabajo)
@@ -157,6 +157,15 @@
         
         # pre-processor 
         'PPHASH',      # '#'
+
+	####################
+	# Ruyk
+	'PRAGMA', # pragma
+	'OMP', # openmp
+	'PARALLEL', # parallel
+	'SHARED', 'PRIVATE', 'REDUCTION', 'NOWAIT',
+        'LKLAUNCH', 'RKLAUNCH', # CUDA kernel launch
+        'GLOBAL',
     )
 
     ##
@@ -209,6 +218,7 @@
         # ppline: preprocessor line directives
         # 
         ('ppline', 'exclusive'),
+        ('directive', 'inclusive'),
     )
     
     def t_PPHASH(self, t):
@@ -216,14 +226,74 @@
         m = self.line_pattern.match(
             t.lexer.lexdata, pos=t.lexer.lexpos)
         
+        t.type = 'PPHASH'
         if m:
             t.lexer.begin('ppline')
             self.pp_line = self.pp_filename = None
-            #~ print "ppline starts on line %s" % t.lexer.lineno
+            # print "ppline starts on line %s" % t.lexer.lineno
         else:
+            t.lexer.begin('directive')
             t.type = 'PPHASH'
             return t
-    
+
+    ####################
+    # Ruyk
+    def t_directive_PRAGMA(self, t):
+        r'pragma'
+        t.type = 'PRAGMA'
+        return t
+
+    def t_directive_OMP(self, t):
+        r'omp'
+        t.type = 'OMP'
+        return t
+
+    def t_directive_PARALLEL(self, t):
+        r'parallel'
+        t.type = 'PARALLEL'
+        return t
+
+    def t_directive_SHARED(self, t):
+        r'shared'
+        t.type = 'SHARED'
+        return t
+
+    def t_directive_PRIVATE(self, t):
+        r'private'
+        t.type = 'PRIVATE'
+        return t
+    def t_directive_REDUCTION(self, t):
+        r'reduction'
+        t.type = 'REDUCTION'
+        return t
+ 
+    def t_directive_NOWAIT(self, t):
+        r'nowait'
+        t.type = 'NOWAIT'
+        return t
+
+
+    def t_directive_NEWLINE(self, t):
+        r'\n'
+                       
+        t.lexer.begin('INITIAL')
+
+
+
+    t_directive_ignore = ' \t'
+
+    def t_directive_error(self, t):
+        msg = 'invalid openmp directive'
+        self._error(msg, t)
+
+
+    # CUDA kernel class
+    def t_GLOBAL(self, t):
+        r'__global__'
+        t.type = 'GLOBAL'
+        return t
+
+
     ##
     ## Rules for the ppline state
     ##
@@ -298,7 +368,12 @@
     t_GE                = r'>='
     t_EQ                = r'=='
     t_NE                = r'!='
+    # *** Ruyk
+    # CUDA kernel launch
+    t_LKLAUNCH            = r'<<<'
+    t_RKLAUNCH            = r'>>>'
 
+
     # Assignment operators
     t_EQUALS            = r'='
     t_TIMESEQUAL        = r'\*='
@@ -337,7 +412,7 @@
 
     t_STRING_LITERAL    = string_literal
     
-    # The following floating and integer constants are defined as 
+#    # The following floating and integer constants are defined as 
     # functions to impose a strict order (otherwise, decimal
     # is placed before the others because its regex is longer,
     # and this is bad)
@@ -410,7 +485,8 @@
 
 
 if __name__ == "__main__":
-    filename = '../zp.c'
+#    filename = '../z_test.c'
+    filename = '../examples/c_files/funky.c'
     text = open(filename).read()
     
     #~ text = '"'+r"""ka \p ka"""+'"'
