Index: pycparser/c_parser.py
===================================================================
--- pycparser/c_parser.py	(revisiÃ³n: 91)
+++ pycparser/c_parser.py	(copia de trabajo)
@@ -292,6 +292,7 @@
             bitsize=None, 
             coord=decl.coord)
         
+
         typename = spec['type']
         declaration = self._fix_decl_name_type(declaration, typename)
         return c_ast.FuncDef(
@@ -362,12 +363,107 @@
         """
         p[0] = p[1]
 
-    def p_pp_directive(self, p):
-        """ pp_directive  : PPHASH 
+    def p_external_declaration_4(self, p):
+        """ external_declaration    : cuda_kernel 
         """
+        p[0] = [p[1]]
+    
+    def p_cuda_kernel(self, p):
+       """ cuda_kernel : GLOBAL function_definition """
+#       p[0] = p[2]
+       p[0] = c_ast.CUDAKernel(
+                        name=p[2].decl.name,
+                        type='global',
+                        function = p[2],
+                        coord=p[2].coord)
+
+
+
+#    def p_pp_directive(self, p):
+#        """ pp_directive  : PPHASH 
+#        """
+#        self._parse_error('Directives not supported yet', 
+#            self._coord(p.lineno(1)))
+
+
+####################
+# Ruyk
+# Adding support for OpenMP 3.0
+
+    def p_pp_directive_1(self, p):
+        """ pp_directive  : PPHASH pragma_directive 
+        """
+        p[0] = p[2]
+#        self._parse_error('Directives not supported yet', 
+#            self._coord(p.lineno(1)))
+
+    def p_pp_directive_2(self, p):
+        """ pp_directive  : PPHASH
+        """
         self._parse_error('Directives not supported yet', 
             self._coord(p.lineno(1)))
 
+    def p_pragma_directive(self, p):
+       """ pragma_directive : PRAGMA OMP directive"""
+       p[0] = [c_ast.Pragma(
+            name='pragma', 
+            child = p[3],
+            coord=self._coord(p.lineno(1)))]
+      # self._parse_error('Directives not supported yet', 
+      #     self._coord(p.lineno(1)))
+
+    def p_directive_1(self, p):
+       """ directive : PARALLEL omp_clause_list
+                     | PARALLEL """
+       # Start of a parallel region
+       p[0] = c_ast.Omp(name='parallel', type = 'parallel', reduction = p[2] if len(p) == 2 else [],
+          shared = [], private = [], coord = self._coord(p.lineno(1)))
+
+    def p_directive_2(self, p):
+       """ directive : PARALLEL FOR omp_clause_list"""
+       # Start of a parallel region within a for
+       reduction_list = []
+       shared_list = []
+       private_list = []
+       for clause in p[3]:
+          if clause.name == 'SHARED': shared_list.append(clause)
+          elif clause.name == 'PRIVATE' : private_list.append(clause)
+          elif clause.name == 'REDUCTION' : reduction_list.append(clause)
+          else:
+             print " Unknown " + clause.type + " clause in " + str(self._coord(p.lineno(1)))
+       p[0] = c_ast.Omp(name='for', type = 'parallel', reduction = reduction_list,
+          shared = shared_list, private = private_list, coord = self._coord(p.lineno(1)))
+
+
+    def p_omp_clause_list(self, p):
+       """ omp_clause_list : omp_clause_list clause
+                           | clause """
+       p[0] = p[1] if len(p) == 2 else p[1] + p[2]
+
+    def p_clause_1(self, p):
+       """ clause : SHARED LPAREN identifier_list RPAREN 
+                  | PRIVATE LPAREN identifier_list RPAREN """
+       p[0] = [c_ast.OmpClause(type = 'memory', name = str(p[1]).upper(), identifiers = [p[3]], coord = self._coord(p.lineno(1)))]
+    def p_clause_2(self, p):
+       """ clause : REDUCTION LPAREN reduction_operator  COLON identifier_list RPAREN """
+       p[0] = [c_ast.OmpClause(type = p[3] , name = str(p[1]).upper(), identifiers = [p[5]], coord = self._coord(p.lineno(1)))]
+
+    def p_clause_3(self, p):
+       """ clause : NOWAIT """
+       p[0] = [c_ast.OmpClause(type = str(p[1]) , name = str(p[1]).upper(), identifiers = [p[5]], coord = self._coord(p.lineno(1)))]
+
+
+    def p_reduction_operator(self, p):
+       """ reduction_operator  : PLUS 
+                               | MINUS
+                               | TIMES """
+       p[0] = p[1]
+
+
+# End of OpenMP
+####################
+
+
     # In function definitions, the declarator can be followed by
     # a declaration list, for old "K&R style" function definitios.
     #
@@ -404,6 +500,13 @@
         """
         p[0] = p[1]
 
+# Ruyk : Directives inside statements
+    def p_statement_1(self, p):
+        """ statement : pp_directive
+        """
+        p[0] = p[1][0]
+
+
     # In C, declarations can come several in a line:
     #   int x, *px, romulo = 5;
     #
@@ -1176,6 +1279,15 @@
         """
         p[0] = c_ast.UnaryOp('p' + p[2], p[1], p[1].coord)
 
+# Ruyk: CUDA Kernel Launch
+    def p_postfix_exptession_6(self, p):
+        """ postfix_expression  : postfix_expression LKLAUNCH primary_expression COMMA primary_expression RKLAUNCH LPAREN argument_expression_list RPAREN
+                                | postfix_expression LKLAUNCH primary_expression COMMA primary_expression RKLAUNCH LPAREN  RPAREN
+
+        """
+        p[0] = c_ast.CUDAKernelCall(p[1], p[3], p[5], p[8] if len(p) > 9 else None, p[1].coord)
+
+
     def p_primary_expression_1(self, p):
         """ primary_expression  : identifier """
         p[0] = p[1]
