Index: z_test.py
===================================================================
--- z_test.py	(revision 88)
+++ z_test.py	(working copy)
@@ -1,23 +1,68 @@
 from pycparser import c_parser, c_ast
 
 source_code = """
-int main()
-{
-    int a;
-    a=1;
-    b=a;
-    printf("%d", b);
-    return;
+
+
+#define  __attribute__(x)  /*NOTHING*/
+
+#define __const
+#define __addr
+#define __THROW
+#define __extension__
+
+# define __inline		
+# define __THROW
+# define __P(args)	args
+# define __PMT(args)	args
+# define __restrict__ 
+# define __restrict
+
+
+#include "/usr/local/cuda/include/cuda.h"
+#include "/usr/local/cuda/include/builtin_types.h"
+
+dim3 dimGrid (numBlocks);
+dim3 tutu(numBlocks);
+
+int main() {
+
+    launch <<< dimGrid, tutu >>> (1,3,5);
+
 }
+
 """
 
-parser = c_parser.CParser()
-ast = parser.parse(source_code)
-function_body = ast.ext[0].body #hardcoded to the main() function
+import subprocess
+from cStringIO import StringIO
 
-for stmt in function_body.stmts:
-    print stmt.coord, stmt
+
+try:
+    p = subprocess.Popen("cpp -ansi -pedantic -CC -U __USE_GNU  -P", shell=True, bufsize=1, stdin=subprocess.PIPE, stdout=subprocess.PIPE, close_fds=True)
+except IOError:
+    exit(0)
+clean_source = p.communicate(source_code)[0]
+
+try:
+	process = subprocess.Popen("sed -nf /home/ruyk/workspace/pycparser-read-only/nocomments", shell = True, stdin=subprocess.PIPE, stdout=subprocess.PIPE)
+except IOError:
+    exit(0)
+stripped_code = process.communicate(clean_source)[0]
+
+
+parser = c_parser.CParser(
+            lex_optimize=False,
+            yacc_optimize=False,
+            yacc_debug=True,
+)
+ast = parser.parse(stripped_code, filename = 'tutu')
+ast.show()
+
+#function_body = ast.ext[0].body #hardcoded to the main() function
+
+#for stmt in function_body.stmts:
+#    print stmt.coord, stmt
     
+    
 #~ class StructRefVisitor(c_ast.NodeVisitor):
     #~ def visit_StructRef(self, node):
         #~ print node.name.name, node.field.name
Index: pycparser/_build_tables.py
===================================================================
--- pycparser/_build_tables.py	(revision 88)
+++ pycparser/_build_tables.py	(working copy)
@@ -20,12 +20,12 @@
 # Generates the tables
 #
 c_parser.CParser(
-    lex_optimize=True, 
-    yacc_debug=False, 
-    yacc_optimize=True)
+    lex_optimize=False, 
+    yacc_debug=True, 
+    yacc_optimize=False)
 
 # Load to compile into .pyc
 #
-import lextab
+# import lextab
 import yacctab
 import c_ast
Index: pycparser/c_ast.py
===================================================================
--- pycparser/c_ast.py	(revision 88)
+++ pycparser/c_ast.py	(working copy)
@@ -1,1163 +1,1245 @@
-#-----------------------------------------------------------------
-# ** ATTENTION **
-# This code was automatically generated from the file:
-# _c_ast.yaml 
-#
-# Do not modify it directly. Modify the configuration file and
-# run the generator again.
-# ** ** *** ** **
-#
-# pycparser: c_ast.py
-#
-# AST Node classes.
-#
-# Copyright (C) 2008, Eli Bendersky
-# License: LGPL
-#-----------------------------------------------------------------
-
-
-import sys
-
-
-class Node(object):
-    """ Abstract base class for AST nodes.
-    """
-    def children(self):
-        """ A sequence of all children that are Nodes
-        """
-        pass
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        """ Pretty print the Node and all its attributes and
-            children (recursively) to a buffer.
-            
-            file:   
-                Open IO buffer into which the Node is printed.
-            
-            offset: 
-                Initial offset (amount of leading spaces) 
-            
-            attrnames:
-                True if you want to see the attribute names in
-                name=value pairs. False to only see the values.
-            
-            showcoord:
-                Do you want the coordinates of each Node to be
-                displayed.
-        """
-        pass
-
-
-class NodeVisitor(object):
-    """ A base NodeVisitor class for visiting c_ast nodes. 
-        Subclass it and define your own visit_XXX methods, where
-        XXX is the class name you want to visit with these 
-        methods.
-        
-        For example:
-        
-        class ConstantVisitor(NodeVisitor):
-            def __init__(self):
-                self.values = []
-            
-            def visit_Constant(self, node):
-                self.values.append(node.value)
-
-        Creates a list of values of all the constant nodes 
-        encountered below the given node. To use it:
-        
-        cv = ConstantVisitor()
-        cv.visit(node)
-        
-        Notes:
-        
-        *   generic_visit() will be called for AST nodes for which 
-            no visit_XXX method was defined. 
-        *   The children of nodes for which a visit_XXX was 
-            defined will not be visited - if you need this, call
-            generic_visit() on the node. 
-            You can use:
-                NodeVisitor.generic_visit(self, node)
-        *   Modeled after Python's own AST visiting facilities
-            (the ast module of Python 3.0)
-    """
-    def visit(self, node):
-        """ Visit a node. 
-        """
-        method = 'visit_' + node.__class__.__name__
-        visitor = getattr(self, method, self.generic_visit)
-        return visitor(node)
-        
-    def generic_visit(self, node):
-        """ Called if no explicit visitor function exists for a 
-            node. Implements preorder visiting of the node.
-        """
-        for c in node.children():
-            self.visit(c)
-
-
-class Typedef(Node):
-    def __init__(self, name, quals, storage, type, coord=None):
-        self.name = name
-        self.quals = quals
-        self.storage = storage
-        self.type = type
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.type is not None: nodelist.append(self.type)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'Typedef: ')
-
-        if attrnames:
-            attrstr = ', '.join('%s=%s' % nv for nv in [("name", repr(self.name)), ("quals", repr(self.quals)), ("storage", repr(self.storage))])
-        else:
-            attrstr = ', '.join('%s' % v for v in [self.name, self.quals, self.storage])
-        buf.write(attrstr)
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class Struct(Node):
-    def __init__(self, name, decls, coord=None):
-        self.name = name
-        self.decls = decls
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.decls is not None: nodelist.extend(self.decls)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'Struct: ')
-
-        if attrnames:
-            attrstr = ', '.join('%s=%s' % nv for nv in [("name", repr(self.name))])
-        else:
-            attrstr = ', '.join('%s' % v for v in [self.name])
-        buf.write(attrstr)
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class FuncCall(Node):
-    def __init__(self, name, args, coord=None):
-        self.name = name
-        self.args = args
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.name is not None: nodelist.append(self.name)
-        if self.args is not None: nodelist.append(self.args)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'FuncCall: ')
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class UnaryOp(Node):
-    def __init__(self, op, expr, coord=None):
-        self.op = op
-        self.expr = expr
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.expr is not None: nodelist.append(self.expr)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'UnaryOp: ')
-
-        if attrnames:
-            attrstr = ', '.join('%s=%s' % nv for nv in [("op", repr(self.op))])
-        else:
-            attrstr = ', '.join('%s' % v for v in [self.op])
-        buf.write(attrstr)
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class Union(Node):
-    def __init__(self, name, decls, coord=None):
-        self.name = name
-        self.decls = decls
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.decls is not None: nodelist.extend(self.decls)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'Union: ')
-
-        if attrnames:
-            attrstr = ', '.join('%s=%s' % nv for nv in [("name", repr(self.name))])
-        else:
-            attrstr = ', '.join('%s' % v for v in [self.name])
-        buf.write(attrstr)
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class TernaryOp(Node):
-    def __init__(self, cond, iftrue, iffalse, coord=None):
-        self.cond = cond
-        self.iftrue = iftrue
-        self.iffalse = iffalse
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.cond is not None: nodelist.append(self.cond)
-        if self.iftrue is not None: nodelist.append(self.iftrue)
-        if self.iffalse is not None: nodelist.append(self.iffalse)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'TernaryOp: ')
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class Label(Node):
-    def __init__(self, name, stmt, coord=None):
-        self.name = name
-        self.stmt = stmt
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.stmt is not None: nodelist.append(self.stmt)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'Label: ')
-
-        if attrnames:
-            attrstr = ', '.join('%s=%s' % nv for nv in [("name", repr(self.name))])
-        else:
-            attrstr = ', '.join('%s' % v for v in [self.name])
-        buf.write(attrstr)
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class IdentifierType(Node):
-    def __init__(self, names, coord=None):
-        self.names = names
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'IdentifierType: ')
-
-        if attrnames:
-            attrstr = ', '.join('%s=%s' % nv for nv in [("names", repr(self.names))])
-        else:
-            attrstr = ', '.join('%s' % v for v in [self.names])
-        buf.write(attrstr)
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class FuncDef(Node):
-    def __init__(self, decl, param_decls, body, coord=None):
-        self.decl = decl
-        self.param_decls = param_decls
-        self.body = body
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.decl is not None: nodelist.append(self.decl)
-        if self.body is not None: nodelist.append(self.body)
-        if self.param_decls is not None: nodelist.extend(self.param_decls)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'FuncDef: ')
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class Enumerator(Node):
-    def __init__(self, name, value, coord=None):
-        self.name = name
-        self.value = value
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.value is not None: nodelist.append(self.value)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'Enumerator: ')
-
-        if attrnames:
-            attrstr = ', '.join('%s=%s' % nv for nv in [("name", repr(self.name))])
-        else:
-            attrstr = ', '.join('%s' % v for v in [self.name])
-        buf.write(attrstr)
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class For(Node):
-    def __init__(self, init, cond, next, stmt, coord=None):
-        self.init = init
-        self.cond = cond
-        self.next = next
-        self.stmt = stmt
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.init is not None: nodelist.append(self.init)
-        if self.cond is not None: nodelist.append(self.cond)
-        if self.next is not None: nodelist.append(self.next)
-        if self.stmt is not None: nodelist.append(self.stmt)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'For: ')
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class Assignment(Node):
-    def __init__(self, op, lvalue, rvalue, coord=None):
-        self.op = op
-        self.lvalue = lvalue
-        self.rvalue = rvalue
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.lvalue is not None: nodelist.append(self.lvalue)
-        if self.rvalue is not None: nodelist.append(self.rvalue)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'Assignment: ')
-
-        if attrnames:
-            attrstr = ', '.join('%s=%s' % nv for nv in [("op", repr(self.op))])
-        else:
-            attrstr = ', '.join('%s' % v for v in [self.op])
-        buf.write(attrstr)
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class FuncDecl(Node):
-    def __init__(self, args, type, coord=None):
-        self.args = args
-        self.type = type
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.args is not None: nodelist.append(self.args)
-        if self.type is not None: nodelist.append(self.type)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'FuncDecl: ')
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class Enum(Node):
-    def __init__(self, name, values, coord=None):
-        self.name = name
-        self.values = values
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.values is not None: nodelist.append(self.values)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'Enum: ')
-
-        if attrnames:
-            attrstr = ', '.join('%s=%s' % nv for nv in [("name", repr(self.name))])
-        else:
-            attrstr = ', '.join('%s' % v for v in [self.name])
-        buf.write(attrstr)
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class ExprList(Node):
-    def __init__(self, exprs, coord=None):
-        self.exprs = exprs
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.exprs is not None: nodelist.extend(self.exprs)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'ExprList: ')
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class Break(Node):
-    def __init__(self, coord=None):
-        self.coord = coord
-
-    def children(self):
-        return ()
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'Break: ')
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class DoWhile(Node):
-    def __init__(self, cond, stmt, coord=None):
-        self.cond = cond
-        self.stmt = stmt
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.cond is not None: nodelist.append(self.cond)
-        if self.stmt is not None: nodelist.append(self.stmt)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'DoWhile: ')
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class StructRef(Node):
-    def __init__(self, name, type, field, coord=None):
-        self.name = name
-        self.type = type
-        self.field = field
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.name is not None: nodelist.append(self.name)
-        if self.field is not None: nodelist.append(self.field)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'StructRef: ')
-
-        if attrnames:
-            attrstr = ', '.join('%s=%s' % nv for nv in [("type", repr(self.type))])
-        else:
-            attrstr = ', '.join('%s' % v for v in [self.type])
-        buf.write(attrstr)
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class BinaryOp(Node):
-    def __init__(self, op, left, right, coord=None):
-        self.op = op
-        self.left = left
-        self.right = right
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.left is not None: nodelist.append(self.left)
-        if self.right is not None: nodelist.append(self.right)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'BinaryOp: ')
-
-        if attrnames:
-            attrstr = ', '.join('%s=%s' % nv for nv in [("op", repr(self.op))])
-        else:
-            attrstr = ', '.join('%s' % v for v in [self.op])
-        buf.write(attrstr)
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class Compound(Node):
-    def __init__(self, decls, stmts, coord=None):
-        self.decls = decls
-        self.stmts = stmts
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.decls is not None: nodelist.extend(self.decls)
-        if self.stmts is not None: nodelist.extend(self.stmts)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'Compound: ')
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class ArrayDecl(Node):
-    def __init__(self, type, dim, coord=None):
-        self.type = type
-        self.dim = dim
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.type is not None: nodelist.append(self.type)
-        if self.dim is not None: nodelist.append(self.dim)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'ArrayDecl: ')
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class Case(Node):
-    def __init__(self, expr, stmt, coord=None):
-        self.expr = expr
-        self.stmt = stmt
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.expr is not None: nodelist.append(self.expr)
-        if self.stmt is not None: nodelist.append(self.stmt)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'Case: ')
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class Cast(Node):
-    def __init__(self, to_type, expr, coord=None):
-        self.to_type = to_type
-        self.expr = expr
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.to_type is not None: nodelist.append(self.to_type)
-        if self.expr is not None: nodelist.append(self.expr)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'Cast: ')
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class TypeDecl(Node):
-    def __init__(self, declname, quals, type, coord=None):
-        self.declname = declname
-        self.quals = quals
-        self.type = type
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.type is not None: nodelist.append(self.type)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'TypeDecl: ')
-
-        if attrnames:
-            attrstr = ', '.join('%s=%s' % nv for nv in [("declname", repr(self.declname)), ("quals", repr(self.quals))])
-        else:
-            attrstr = ', '.join('%s' % v for v in [self.declname, self.quals])
-        buf.write(attrstr)
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class Default(Node):
-    def __init__(self, stmt, coord=None):
-        self.stmt = stmt
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.stmt is not None: nodelist.append(self.stmt)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'Default: ')
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class PtrDecl(Node):
-    def __init__(self, quals, type, coord=None):
-        self.quals = quals
-        self.type = type
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.type is not None: nodelist.append(self.type)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'PtrDecl: ')
-
-        if attrnames:
-            attrstr = ', '.join('%s=%s' % nv for nv in [("quals", repr(self.quals))])
-        else:
-            attrstr = ', '.join('%s' % v for v in [self.quals])
-        buf.write(attrstr)
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class Switch(Node):
-    def __init__(self, cond, stmt, coord=None):
-        self.cond = cond
-        self.stmt = stmt
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.cond is not None: nodelist.append(self.cond)
-        if self.stmt is not None: nodelist.append(self.stmt)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'Switch: ')
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class Continue(Node):
-    def __init__(self, coord=None):
-        self.coord = coord
-
-    def children(self):
-        return ()
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'Continue: ')
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class ParamList(Node):
-    def __init__(self, params, coord=None):
-        self.params = params
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.params is not None: nodelist.extend(self.params)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'ParamList: ')
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class Return(Node):
-    def __init__(self, expr, coord=None):
-        self.expr = expr
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.expr is not None: nodelist.append(self.expr)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'Return: ')
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class Typename(Node):
-    def __init__(self, quals, type, coord=None):
-        self.quals = quals
-        self.type = type
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.type is not None: nodelist.append(self.type)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'Typename: ')
-
-        if attrnames:
-            attrstr = ', '.join('%s=%s' % nv for nv in [("quals", repr(self.quals))])
-        else:
-            attrstr = ', '.join('%s' % v for v in [self.quals])
-        buf.write(attrstr)
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class ID(Node):
-    def __init__(self, name, coord=None):
-        self.name = name
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'ID: ')
-
-        if attrnames:
-            attrstr = ', '.join('%s=%s' % nv for nv in [("name", repr(self.name))])
-        else:
-            attrstr = ', '.join('%s' % v for v in [self.name])
-        buf.write(attrstr)
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class Goto(Node):
-    def __init__(self, name, coord=None):
-        self.name = name
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'Goto: ')
-
-        if attrnames:
-            attrstr = ', '.join('%s=%s' % nv for nv in [("name", repr(self.name))])
-        else:
-            attrstr = ', '.join('%s' % v for v in [self.name])
-        buf.write(attrstr)
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class Decl(Node):
-    def __init__(self, name, quals, storage, type, init, bitsize, coord=None):
-        self.name = name
-        self.quals = quals
-        self.storage = storage
-        self.type = type
-        self.init = init
-        self.bitsize = bitsize
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.type is not None: nodelist.append(self.type)
-        if self.init is not None: nodelist.append(self.init)
-        if self.bitsize is not None: nodelist.append(self.bitsize)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'Decl: ')
-
-        if attrnames:
-            attrstr = ', '.join('%s=%s' % nv for nv in [("name", repr(self.name)), ("quals", repr(self.quals)), ("storage", repr(self.storage))])
-        else:
-            attrstr = ', '.join('%s' % v for v in [self.name, self.quals, self.storage])
-        buf.write(attrstr)
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class Constant(Node):
-    def __init__(self, type, value, coord=None):
-        self.type = type
-        self.value = value
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'Constant: ')
-
-        if attrnames:
-            attrstr = ', '.join('%s=%s' % nv for nv in [("type", repr(self.type)), ("value", repr(self.value))])
-        else:
-            attrstr = ', '.join('%s' % v for v in [self.type, self.value])
-        buf.write(attrstr)
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class FileAST(Node):
-    def __init__(self, ext, coord=None):
-        self.ext = ext
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.ext is not None: nodelist.extend(self.ext)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'FileAST: ')
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class ArrayRef(Node):
-    def __init__(self, name, subscript, coord=None):
-        self.name = name
-        self.subscript = subscript
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.name is not None: nodelist.append(self.name)
-        if self.subscript is not None: nodelist.append(self.subscript)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'ArrayRef: ')
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class While(Node):
-    def __init__(self, cond, stmt, coord=None):
-        self.cond = cond
-        self.stmt = stmt
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.cond is not None: nodelist.append(self.cond)
-        if self.stmt is not None: nodelist.append(self.stmt)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'While: ')
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class EnumeratorList(Node):
-    def __init__(self, enumerators, coord=None):
-        self.enumerators = enumerators
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.enumerators is not None: nodelist.extend(self.enumerators)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'EnumeratorList: ')
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class EllipsisParam(Node):
-    def __init__(self, coord=None):
-        self.coord = coord
-
-    def children(self):
-        return ()
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'EllipsisParam: ')
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
-class If(Node):
-    def __init__(self, cond, iftrue, iffalse, coord=None):
-        self.cond = cond
-        self.iftrue = iftrue
-        self.iffalse = iffalse
-        self.coord = coord
-
-    def children(self):
-        nodelist = []
-        if self.cond is not None: nodelist.append(self.cond)
-        if self.iftrue is not None: nodelist.append(self.iftrue)
-        if self.iffalse is not None: nodelist.append(self.iffalse)
-        return tuple(nodelist)
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        lead = ' ' * offset
-        buf.write(lead + 'If: ')
-
-        if showcoord:
-            buf.write(' (at %s)' % self.coord)
-        buf.write('\n')
-
-        for c in self.children():
-            c.show(buf, offset + 2, attrnames, showcoord)
-
-
+#-----------------------------------------------------------------
+# ** ATTENTION **
+# This code was automatically generated from the file:
+# _c_ast.yaml 
+#
+# Do not modify it directly. Modify the configuration file and
+# run the generator again.
+# ** ** *** ** **
+#
+# pycparser: c_ast.py
+#
+# AST Node classes.
+#
+# Copyright (C) 2008, Eli Bendersky
+# License: LGPL
+#-----------------------------------------------------------------
+
+
+import sys
+
+
+class Node(object):
+    """ Abstract base class for AST nodes.
+    """
+    def children(self):
+        """ A sequence of all children that are Nodes
+        """
+        pass
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        """ Pretty print the Node and all its attributes and
+            children (recursively) to a buffer.
+            
+            file:   
+                Open IO buffer into which the Node is printed.
+            
+            offset: 
+                Initial offset (amount of leading spaces) 
+            
+            attrnames:
+                True if you want to see the attribute names in
+                name=value pairs. False to only see the values.
+            
+            showcoord:
+                Do you want the coordinates of each Node to be
+                displayed.
+        """
+        pass
+
+
+class NodeVisitor(object):
+    """ A base NodeVisitor class for visiting c_ast nodes. 
+        Subclass it and define your own visit_XXX methods, where
+        XXX is the class name you want to visit with these 
+        methods.
+        
+        For example:
+        
+        class ConstantVisitor(NodeVisitor):
+            def __init__(self):
+                self.values = []
+            
+            def visit_Constant(self, node):
+                self.values.append(node.value)
+
+        Creates a list of values of all the constant nodes 
+        encountered below the given node. To use it:
+        
+        cv = ConstantVisitor()
+        cv.visit(node)
+        
+        Notes:
+        
+        *   generic_visit() will be called for AST nodes for which 
+            no visit_XXX method was defined. 
+        *   The children of nodes for which a visit_XXX was 
+            defined will not be visited - if you need this, call
+            generic_visit() on the node. 
+            You can use:
+                NodeVisitor.generic_visit(self, node)
+        *   Modeled after Python's own AST visiting facilities
+            (the ast module of Python 3.0)
+    """
+    def visit(self, node):
+        """ Visit a node. 
+        """
+        method = 'visit_' + node.__class__.__name__
+        visitor = getattr(self, method, self.generic_visit)
+        return visitor(node)
+        
+    def generic_visit(self, node):
+        """ Called if no explicit visitor function exists for a 
+            node. Implements preorder visiting of the node.
+        """
+        for c in node.children():
+            self.visit(c)
+
+
+class Typedef(Node):
+    def __init__(self, name, quals, storage, type, coord=None):
+        self.name = name
+        self.quals = quals
+        self.storage = storage
+        self.type = type
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.type is not None: nodelist.append(self.type)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'Typedef: ')
+
+        if attrnames:
+            attrstr = ', '.join('%s=%s' % nv for nv in [("name", repr(self.name)), ("quals", repr(self.quals)), ("storage", repr(self.storage))])
+        else:
+            attrstr = ', '.join('%s' % v for v in [self.name, self.quals, self.storage])
+        buf.write(attrstr)
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class Struct(Node):
+    def __init__(self, name, decls, coord=None):
+        self.name = name
+        self.decls = decls
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.decls is not None: nodelist.extend(self.decls)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'Struct: ')
+
+        if attrnames:
+            attrstr = ', '.join('%s=%s' % nv for nv in [("name", repr(self.name))])
+        else:
+            attrstr = ', '.join('%s' % v for v in [self.name])
+        buf.write(attrstr)
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class FuncCall(Node):
+    def __init__(self, name, args, coord=None):
+        self.name = name
+        self.args = args
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.name is not None: nodelist.append(self.name)
+        if self.args is not None: nodelist.append(self.args)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'FuncCall: ')
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class UnaryOp(Node):
+    def __init__(self, op, expr, coord=None):
+        self.op = op
+        self.expr = expr
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.expr is not None: nodelist.append(self.expr)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'UnaryOp: ')
+
+        if attrnames:
+            attrstr = ', '.join('%s=%s' % nv for nv in [("op", repr(self.op))])
+        else:
+            attrstr = ', '.join('%s' % v for v in [self.op])
+        buf.write(attrstr)
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class Union(Node):
+    def __init__(self, name, decls, coord=None):
+        self.name = name
+        self.decls = decls
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.decls is not None: nodelist.extend(self.decls)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'Union: ')
+
+        if attrnames:
+            attrstr = ', '.join('%s=%s' % nv for nv in [("name", repr(self.name))])
+        else:
+            attrstr = ', '.join('%s' % v for v in [self.name])
+        buf.write(attrstr)
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class TernaryOp(Node):
+    def __init__(self, cond, iftrue, iffalse, coord=None):
+        self.cond = cond
+        self.iftrue = iftrue
+        self.iffalse = iffalse
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.cond is not None: nodelist.append(self.cond)
+        if self.iftrue is not None: nodelist.append(self.iftrue)
+        if self.iffalse is not None: nodelist.append(self.iffalse)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'TernaryOp: ')
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class Label(Node):
+    def __init__(self, name, stmt, coord=None):
+        self.name = name
+        self.stmt = stmt
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.stmt is not None: nodelist.append(self.stmt)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'Label: ')
+
+        if attrnames:
+            attrstr = ', '.join('%s=%s' % nv for nv in [("name", repr(self.name))])
+        else:
+            attrstr = ', '.join('%s' % v for v in [self.name])
+        buf.write(attrstr)
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class IdentifierType(Node):
+    def __init__(self, names, coord=None):
+        self.names = names
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'IdentifierType: ')
+
+        if attrnames:
+            attrstr = ', '.join('%s=%s' % nv for nv in [("names", repr(self.names))])
+        else:
+            attrstr = ', '.join('%s' % v for v in [self.names])
+        buf.write(attrstr)
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class FuncDef(Node):
+    def __init__(self, decl, param_decls, body, coord=None):
+        self.decl = decl
+        self.param_decls = param_decls
+        self.body = body
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.decl is not None: nodelist.append(self.decl)
+        if self.body is not None: nodelist.append(self.body)
+        if self.param_decls is not None: nodelist.extend(self.param_decls)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'FuncDef: ')
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class CUDAKernelCall(Node):
+    def __init__(self, name, grid, block, args, coord=None):
+        self.name = name
+        self.grid = grid
+        self.block = block
+        self.args = args
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.name is not None: nodelist.append(self.name)
+        if self.grid is not None: nodelist.append(self.grid)
+        if self.block is not None: nodelist.append(self.block)
+        if self.args is not None: nodelist.append(self.args)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'CUDAKernelCall: ')
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class Enumerator(Node):
+    def __init__(self, name, value, coord=None):
+        self.name = name
+        self.value = value
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.value is not None: nodelist.append(self.value)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'Enumerator: ')
+
+        if attrnames:
+            attrstr = ', '.join('%s=%s' % nv for nv in [("name", repr(self.name))])
+        else:
+            attrstr = ', '.join('%s' % v for v in [self.name])
+        buf.write(attrstr)
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class For(Node):
+    def __init__(self, init, cond, next, stmt, coord=None):
+        self.init = init
+        self.cond = cond
+        self.next = next
+        self.stmt = stmt
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.init is not None: nodelist.append(self.init)
+        if self.cond is not None: nodelist.append(self.cond)
+        if self.next is not None: nodelist.append(self.next)
+        if self.stmt is not None: nodelist.append(self.stmt)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'For: ')
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class Assignment(Node):
+    def __init__(self, op, lvalue, rvalue, coord=None):
+        self.op = op
+        self.lvalue = lvalue
+        self.rvalue = rvalue
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.lvalue is not None: nodelist.append(self.lvalue)
+        if self.rvalue is not None: nodelist.append(self.rvalue)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'Assignment: ')
+
+        if attrnames:
+            attrstr = ', '.join('%s=%s' % nv for nv in [("op", repr(self.op))])
+        else:
+            attrstr = ', '.join('%s' % v for v in [self.op])
+        buf.write(attrstr)
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class FuncDecl(Node):
+    def __init__(self, args, type, coord=None):
+        self.args = args
+        self.type = type
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.args is not None: nodelist.append(self.args)
+        if self.type is not None: nodelist.append(self.type)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'FuncDecl: ')
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class Enum(Node):
+    def __init__(self, name, values, coord=None):
+        self.name = name
+        self.values = values
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.values is not None: nodelist.append(self.values)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'Enum: ')
+
+        if attrnames:
+            attrstr = ', '.join('%s=%s' % nv for nv in [("name", repr(self.name))])
+        else:
+            attrstr = ', '.join('%s' % v for v in [self.name])
+        buf.write(attrstr)
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class ExprList(Node):
+    def __init__(self, exprs, coord=None):
+        self.exprs = exprs
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.exprs is not None: nodelist.extend(self.exprs)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'ExprList: ')
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class Break(Node):
+    def __init__(self, coord=None):
+        self.coord = coord
+
+    def children(self):
+        return ()
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'Break: ')
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class DoWhile(Node):
+    def __init__(self, cond, stmt, coord=None):
+        self.cond = cond
+        self.stmt = stmt
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.cond is not None: nodelist.append(self.cond)
+        if self.stmt is not None: nodelist.append(self.stmt)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'DoWhile: ')
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class Omp(Node):
+    def __init__(self, name, coord=None):
+        self.name = name
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'Omp: ')
+
+        if attrnames:
+            attrstr = ', '.join('%s=%s' % nv for nv in [("name", repr(self.name))])
+        else:
+            attrstr = ', '.join('%s' % v for v in [self.name])
+        buf.write(attrstr)
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class BinaryOp(Node):
+    def __init__(self, op, left, right, coord=None):
+        self.op = op
+        self.left = left
+        self.right = right
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.left is not None: nodelist.append(self.left)
+        if self.right is not None: nodelist.append(self.right)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'BinaryOp: ')
+
+        if attrnames:
+            attrstr = ', '.join('%s=%s' % nv for nv in [("op", repr(self.op))])
+        else:
+            attrstr = ', '.join('%s' % v for v in [self.op])
+        buf.write(attrstr)
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class Compound(Node):
+    def __init__(self, decls, stmts, coord=None):
+        self.decls = decls
+        self.stmts = stmts
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.decls is not None: nodelist.extend(self.decls)
+        if self.stmts is not None: nodelist.extend(self.stmts)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'Compound: ')
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class ArrayDecl(Node):
+    def __init__(self, type, dim, coord=None):
+        self.type = type
+        self.dim = dim
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.type is not None: nodelist.append(self.type)
+        if self.dim is not None: nodelist.append(self.dim)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'ArrayDecl: ')
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class Case(Node):
+    def __init__(self, expr, stmt, coord=None):
+        self.expr = expr
+        self.stmt = stmt
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.expr is not None: nodelist.append(self.expr)
+        if self.stmt is not None: nodelist.append(self.stmt)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'Case: ')
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class StructRef(Node):
+    def __init__(self, name, type, field, coord=None):
+        self.name = name
+        self.type = type
+        self.field = field
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.name is not None: nodelist.append(self.name)
+        if self.field is not None: nodelist.append(self.field)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'StructRef: ')
+
+        if attrnames:
+            attrstr = ', '.join('%s=%s' % nv for nv in [("type", repr(self.type))])
+        else:
+            attrstr = ', '.join('%s' % v for v in [self.type])
+        buf.write(attrstr)
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class Cast(Node):
+    def __init__(self, to_type, expr, coord=None):
+        self.to_type = to_type
+        self.expr = expr
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.to_type is not None: nodelist.append(self.to_type)
+        if self.expr is not None: nodelist.append(self.expr)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'Cast: ')
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class TypeDecl(Node):
+    def __init__(self, declname, quals, type, coord=None):
+        self.declname = declname
+        self.quals = quals
+        self.type = type
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.type is not None: nodelist.append(self.type)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'TypeDecl: ')
+
+        if attrnames:
+            attrstr = ', '.join('%s=%s' % nv for nv in [("declname", repr(self.declname)), ("quals", repr(self.quals))])
+        else:
+            attrstr = ', '.join('%s' % v for v in [self.declname, self.quals])
+        buf.write(attrstr)
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class Pragma(Node):
+    def __init__(self, name, coord=None):
+        self.name = name
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'Pragma: ')
+
+        if attrnames:
+            attrstr = ', '.join('%s=%s' % nv for nv in [("name", repr(self.name))])
+        else:
+            attrstr = ', '.join('%s' % v for v in [self.name])
+        buf.write(attrstr)
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class Default(Node):
+    def __init__(self, stmt, coord=None):
+        self.stmt = stmt
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.stmt is not None: nodelist.append(self.stmt)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'Default: ')
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class PtrDecl(Node):
+    def __init__(self, quals, type, coord=None):
+        self.quals = quals
+        self.type = type
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.type is not None: nodelist.append(self.type)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'PtrDecl: ')
+
+        if attrnames:
+            attrstr = ', '.join('%s=%s' % nv for nv in [("quals", repr(self.quals))])
+        else:
+            attrstr = ', '.join('%s' % v for v in [self.quals])
+        buf.write(attrstr)
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class Switch(Node):
+    def __init__(self, cond, stmt, coord=None):
+        self.cond = cond
+        self.stmt = stmt
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.cond is not None: nodelist.append(self.cond)
+        if self.stmt is not None: nodelist.append(self.stmt)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'Switch: ')
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class Continue(Node):
+    def __init__(self, coord=None):
+        self.coord = coord
+
+    def children(self):
+        return ()
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'Continue: ')
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class ParamList(Node):
+    def __init__(self, params, coord=None):
+        self.params = params
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.params is not None: nodelist.extend(self.params)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'ParamList: ')
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class Return(Node):
+    def __init__(self, expr, coord=None):
+        self.expr = expr
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.expr is not None: nodelist.append(self.expr)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'Return: ')
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class Typename(Node):
+    def __init__(self, quals, type, coord=None):
+        self.quals = quals
+        self.type = type
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.type is not None: nodelist.append(self.type)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'Typename: ')
+
+        if attrnames:
+            attrstr = ', '.join('%s=%s' % nv for nv in [("quals", repr(self.quals))])
+        else:
+            attrstr = ', '.join('%s' % v for v in [self.quals])
+        buf.write(attrstr)
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class ID(Node):
+    def __init__(self, name, coord=None):
+        self.name = name
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'ID: ')
+
+        if attrnames:
+            attrstr = ', '.join('%s=%s' % nv for nv in [("name", repr(self.name))])
+        else:
+            attrstr = ', '.join('%s' % v for v in [self.name])
+        buf.write(attrstr)
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class Goto(Node):
+    def __init__(self, name, coord=None):
+        self.name = name
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'Goto: ')
+
+        if attrnames:
+            attrstr = ', '.join('%s=%s' % nv for nv in [("name", repr(self.name))])
+        else:
+            attrstr = ', '.join('%s' % v for v in [self.name])
+        buf.write(attrstr)
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class Decl(Node):
+    def __init__(self, name, quals, storage, type, init, bitsize, coord=None):
+        self.name = name
+        self.quals = quals
+        self.storage = storage
+        self.type = type
+        self.init = init
+        self.bitsize = bitsize
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.type is not None: nodelist.append(self.type)
+        if self.init is not None: nodelist.append(self.init)
+        if self.bitsize is not None: nodelist.append(self.bitsize)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'Decl: ')
+
+        if attrnames:
+            attrstr = ', '.join('%s=%s' % nv for nv in [("name", repr(self.name)), ("quals", repr(self.quals)), ("storage", repr(self.storage))])
+        else:
+            attrstr = ', '.join('%s' % v for v in [self.name, self.quals, self.storage])
+        buf.write(attrstr)
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class Constant(Node):
+    def __init__(self, type, value, coord=None):
+        self.type = type
+        self.value = value
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'Constant: ')
+
+        if attrnames:
+            attrstr = ', '.join('%s=%s' % nv for nv in [("type", repr(self.type)), ("value", repr(self.value))])
+        else:
+            attrstr = ', '.join('%s' % v for v in [self.type, self.value])
+        buf.write(attrstr)
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class FileAST(Node):
+    def __init__(self, ext, coord=None):
+        self.ext = ext
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.ext is not None: nodelist.extend(self.ext)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'FileAST: ')
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class ArrayRef(Node):
+    def __init__(self, name, subscript, coord=None):
+        self.name = name
+        self.subscript = subscript
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.name is not None: nodelist.append(self.name)
+        if self.subscript is not None: nodelist.append(self.subscript)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'ArrayRef: ')
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class While(Node):
+    def __init__(self, cond, stmt, coord=None):
+        self.cond = cond
+        self.stmt = stmt
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.cond is not None: nodelist.append(self.cond)
+        if self.stmt is not None: nodelist.append(self.stmt)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'While: ')
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class EnumeratorList(Node):
+    def __init__(self, enumerators, coord=None):
+        self.enumerators = enumerators
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.enumerators is not None: nodelist.extend(self.enumerators)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'EnumeratorList: ')
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class EllipsisParam(Node):
+    def __init__(self, coord=None):
+        self.coord = coord
+
+    def children(self):
+        return ()
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'EllipsisParam: ')
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
+class If(Node):
+    def __init__(self, cond, iftrue, iffalse, coord=None):
+        self.cond = cond
+        self.iftrue = iftrue
+        self.iffalse = iffalse
+        self.coord = coord
+
+    def children(self):
+        nodelist = []
+        if self.cond is not None: nodelist.append(self.cond)
+        if self.iftrue is not None: nodelist.append(self.iftrue)
+        if self.iffalse is not None: nodelist.append(self.iffalse)
+        return tuple(nodelist)
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        lead = ' ' * offset
+        buf.write(lead + 'If: ')
+
+        if showcoord:
+            buf.write(' (at %s)' % self.coord)
+        buf.write('\n')
+
+        for c in self.children():
+            c.show(buf, offset + 2, attrnames, showcoord)
+
+
Index: pycparser/c_parser.py
===================================================================
--- pycparser/c_parser.py	(revision 88)
+++ pycparser/c_parser.py	(working copy)
@@ -1,1259 +1,1298 @@
-#-----------------------------------------------------------------
-# pycparser: cparse.py
-#
-# CParser class: Parser and AST builder for the C language
-#
-# Copyright (C) 2008, Eli Bendersky
-# License: LGPL
-#-----------------------------------------------------------------
-
-import re
-import sys
-from types import StringType
-
-import ply.yacc
-
-import c_ast
-from c_lexer import CLexer
-from plyparser import PLYParser, Coord, ParseError
-
-
+#-----------------------------------------------------------------
+# pycparser: cparse.py
+#
+# CParser class: Parser and AST builder for the C language
+#
+# Copyright (C) 2008, Eli Bendersky
+# License: LGPL
+#-----------------------------------------------------------------
+
+import re
+import sys
+from types import StringType
+
+import ply.yacc
+
+import c_ast
+from c_lexer import CLexer
+from plyparser import PLYParser, Coord, ParseError
+
+
 class CParser(PLYParser):    
-    def __init__(
-            self, 
-            lex_optimize=True,
-            lextab='pycparser.lextab',
-            yacc_optimize=True,
-            yacctab='pycparser.yacctab',
-            yacc_debug=False):
-        """ Create a new CParser.
-        
-            Some arguments for controlling the debug/optimization
-            level of the parser are provided. The defaults are 
-            tuned for release/performance mode. 
-            The simple rules for using them are:
-            *) When tweaking CParser/CLexer, set these to False
-            *) When releasing a stable parser, set to True
-            
-            lex_optimize:
-                Set to False when you're modifying the lexer.
-                Otherwise, changes in the lexer won't be used, if
-                some lextab.py file exists.
-                When releasing with a stable lexer, set to True
-                to save the re-generation of the lexer table on 
-                each run.
-            
-            lextab:
-                Points to the lex table that's used for optimized
-                mode. Only if you're modifying the lexer and want
-                some tests to avoid re-generating the table, make 
-                this point to a local lex table file (that's been
-                earlier generated with lex_optimize=True)
-            
-            yacc_optimize:
-                Set to False when you're modifying the parser.
-                Otherwise, changes in the parser won't be used, if
-                some parsetab.py file exists.
-                When releasing with a stable parser, set to True
-                to save the re-generation of the parser table on 
-                each run.
-            
-            yacctab:
-                Points to the yacc table that's used for optimized
-                mode. Only if you're modifying the parser, make 
-                this point to a local yacc table file
-                        
-            yacc_debug:
-                Generate a parser.out file that explains how yacc
+    def __init__(
+            self, 
+            lex_optimize=True,
+            lextab='pycparser.lextab',
+            yacc_optimize=True,
+            yacctab='pycparser.yacctab',
+            yacc_debug=False):
+        """ Create a new CParser.
+        
+            Some arguments for controlling the debug/optimization
+            level of the parser are provided. The defaults are 
+            tuned for release/performance mode. 
+            The simple rules for using them are:
+            *) When tweaking CParser/CLexer, set these to False
+            *) When releasing a stable parser, set to True
+            
+            lex_optimize:
+                Set to False when you're modifying the lexer.
+                Otherwise, changes in the lexer won't be used, if
+                some lextab.py file exists.
+                When releasing with a stable lexer, set to True
+                to save the re-generation of the lexer table on 
+                each run.
+            
+            lextab:
+                Points to the lex table that's used for optimized
+                mode. Only if you're modifying the lexer and want
+                some tests to avoid re-generating the table, make 
+                this point to a local lex table file (that's been
+                earlier generated with lex_optimize=True)
+            
+            yacc_optimize:
+                Set to False when you're modifying the parser.
+                Otherwise, changes in the parser won't be used, if
+                some parsetab.py file exists.
+                When releasing with a stable parser, set to True
+                to save the re-generation of the parser table on 
+                each run.
+            
+            yacctab:
+                Points to the yacc table that's used for optimized
+                mode. Only if you're modifying the parser, make 
+                this point to a local yacc table file
+                        
+            yacc_debug:
+                Generate a parser.out file that explains how yacc
                 built the parsing table from the grammar.
-        """
-        self.clex = CLexer(
-            error_func=self._lex_error_func,
-            type_lookup_func=self._lex_type_lookup_func)
-            
-        self.clex.build(
-            optimize=lex_optimize,
-            lextab=lextab)
-        self.tokens = self.clex.tokens
-        
-        rules_with_opt = [
-            'abstract_declarator',
-            'constant_expression',
-            'declaration_list',
-            'declaration_specifiers',
-            'expression',
-            'identifier_list',
-            'init_declarator_list',
-            'parameter_type_list',
-            'specifier_qualifier_list',
-            'statement_list',
-            'type_qualifier_list',
-        ]
-        
-        for rule in rules_with_opt:
-            self._create_opt_rule(rule)
-        
-        self.cparser = ply.yacc.yacc(
-            module=self, 
-            start='translation_unit',
-            debug=yacc_debug,
-            optimize=yacc_optimize,
-            tabmodule=yacctab)
-        
-        # A table of identifiers defined as typedef types during
-        # parsing.
-        #
-        self.typedef_table = set([])
-    
-    def parse(self, text, filename='', debuglevel=0):
-        """ Parses C code and returns an AST.
-        
-            text:
-                A string containing the C source code
-            
-            filename:
-                Name of the file being parsed (for meaningful
-                error messages)
-            
-            debuglevel:
+        """
+        self.clex = CLexer(
+            error_func=self._lex_error_func,
+            type_lookup_func=self._lex_type_lookup_func)
+            
+        self.clex.build(
+            optimize=lex_optimize,
+            lextab=lextab)
+        self.tokens = self.clex.tokens
+        
+        rules_with_opt = [
+            'abstract_declarator',
+            'constant_expression',
+            'declaration_list',
+            'declaration_specifiers',
+            'expression',
+            'identifier_list',
+            'init_declarator_list',
+            'parameter_type_list',
+            'specifier_qualifier_list',
+            'statement_list',
+            'type_qualifier_list',
+        ]
+        
+        for rule in rules_with_opt:
+            self._create_opt_rule(rule)
+        
+        self.cparser = ply.yacc.yacc(
+            module=self, 
+            start='translation_unit',
+            debug=yacc_debug,
+            optimize=yacc_optimize,
+            tabmodule=yacctab)
+        
+        # A table of identifiers defined as typedef types during
+        # parsing.
+        #
+        self.typedef_table = set([])
+    
+    def parse(self, text, filename='', debuglevel=0):
+        """ Parses C code and returns an AST.
+        
+            text:
+                A string containing the C source code
+            
+            filename:
+                Name of the file being parsed (for meaningful
+                error messages)
+            
+            debuglevel:
                 Debug level to yacc
-        """
-        self.clex.filename = filename
-        self.clex.reset_lineno()
-        self.typedef_table = set([])
+        """
+        self.clex.filename = filename
+        self.clex.reset_lineno()
+        self.typedef_table = set([])
         return self.cparser.parse(text, lexer=self.clex, debug=debuglevel)
-    
-    ######################--   PRIVATE   --######################
-    
-    def _lex_error_func(self, msg, line, column):
-        self._parse_error(msg, self._coord(line, column))
-    
-    def _lex_type_lookup_func(self, name):
-        """ Looks up types that were previously defined with
-            typedef. 
-            Passed to the lexer for recognizing identifiers that
+    
+    ######################--   PRIVATE   --######################
+    
+    def _lex_error_func(self, msg, line, column):
+        self._parse_error(msg, self._coord(line, column))
+    
+    def _lex_type_lookup_func(self, name):
+        """ Looks up types that were previously defined with
+            typedef. 
+            Passed to the lexer for recognizing identifiers that
             are types.
-        """
-        return name in self.typedef_table
-    
+        """
+        return name in self.typedef_table
+    
     def _add_typedef_type(self, name):
-        """ Adds names that were defined as new types with 
+        """ Adds names that were defined as new types with 
             typedef.
-        """
-        self.typedef_table.add(name)
-    
-    # To understand what's going on here, read sections A.8.5 and 
-    # A.8.6 of K&R2 very carefully.
-    # 
-    # A C type consists of a basic type declaration, with a list
-    # of modifiers. For example:
-    #
-    # int *c[5];
-    #
-    # The basic declaration here is 'int x', and the pointer and
-    # the array are the modifiers.
-    #
-    # Basic declarations are represented by TypeDecl (from module
-    # c_ast) and the modifiers are FuncDecl, PtrDecl and 
-    # ArrayDecl.
-    #
-    # The standard states that whenever a new modifier is parsed,
-    # it should be added to the end of the list of modifiers. For
-    # example:
-    #
-    # K&R2 A.8.6.2: Array Declarators
-    #
-    # In a declaration T D where D has the form  
-    #   D1 [constant-expression-opt]  
-    # and the type of the identifier in the declaration T D1 is 
-    # "type-modifier T", the type of the 
-    # identifier of D is "type-modifier array of T"
-    #
-    # This is what this method does. The declarator it receives
-    # can be a list of declarators ending with TypeDecl. It 
-    # tacks the modifier to the end of this list, just before 
-    # the TypeDecl.
-    #
-    # Additionally, the modifier may be a list itself. This is 
-    # useful for pointers, that can come as a chain from the rule
-    # p_pointer. In this case, the whole modifier list is spliced 
-    # into the new location.
-    #
-    def _type_modify_decl(self, decl, modifier):
-        """ Tacks a type modifier on a declarator, and returns
-            the modified declarator.
-            
+        """
+        self.typedef_table.add(name)
+    
+    # To understand what's going on here, read sections A.8.5 and 
+    # A.8.6 of K&R2 very carefully.
+    # 
+    # A C type consists of a basic type declaration, with a list
+    # of modifiers. For example:
+    #
+    # int *c[5];
+    #
+    # The basic declaration here is 'int x', and the pointer and
+    # the array are the modifiers.
+    #
+    # Basic declarations are represented by TypeDecl (from module
+    # c_ast) and the modifiers are FuncDecl, PtrDecl and 
+    # ArrayDecl.
+    #
+    # The standard states that whenever a new modifier is parsed,
+    # it should be added to the end of the list of modifiers. For
+    # example:
+    #
+    # K&R2 A.8.6.2: Array Declarators
+    #
+    # In a declaration T D where D has the form  
+    #   D1 [constant-expression-opt]  
+    # and the type of the identifier in the declaration T D1 is 
+    # "type-modifier T", the type of the 
+    # identifier of D is "type-modifier array of T"
+    #
+    # This is what this method does. The declarator it receives
+    # can be a list of declarators ending with TypeDecl. It 
+    # tacks the modifier to the end of this list, just before 
+    # the TypeDecl.
+    #
+    # Additionally, the modifier may be a list itself. This is 
+    # useful for pointers, that can come as a chain from the rule
+    # p_pointer. In this case, the whole modifier list is spliced 
+    # into the new location.
+    #
+    def _type_modify_decl(self, decl, modifier):
+        """ Tacks a type modifier on a declarator, and returns
+            the modified declarator.
+            
             Note: the declarator and modifier may be modified
-        """
-        #~ print '****'
-        #~ decl.show(offset=3)
-        #~ modifier.show(offset=3)
-        #~ print '****'
-        
-        modifier_head = modifier
-        modifier_tail = modifier
-        
-        # The modifier may be a nested list. Reach its tail.
-        #
-        while modifier_tail.type: 
-            modifier_tail = modifier_tail.type
-        
-        # If the decl is a basic type, just tack the modifier onto
-        # it
+        """
+        #~ print '****'
+        #~ decl.show(offset=3)
+        #~ modifier.show(offset=3)
+        #~ print '****'
+        
+        modifier_head = modifier
+        modifier_tail = modifier
+        
+        # The modifier may be a nested list. Reach its tail.
         #
-        if isinstance(decl, c_ast.TypeDecl):
-            modifier_tail.type = decl
-            return modifier
-        else:
-            # Otherwise, the decl is a list of modifiers. Reach
-            # its tail and splice the modifier onto the tail,
-            # pointing to the underlying basic type.
-            #
-            decl_tail = decl
-            
-            while not isinstance(decl_tail.type, c_ast.TypeDecl):
-                decl_tail = decl_tail.type
-            
-            modifier_tail.type = decl_tail.type
-            decl_tail.type = modifier_head
-            return decl
-
-    # Due to the order in which declarators are constructed,
-    # they have to be fixed in order to look like a normal AST.
-    # 
-    # When a declaration arrives from syntax construction, it has
-    # these problems:
-    # * The innermost TypeDecl has no type (because the basic
-    #   type is only known at the uppermost declaration level)
-    # * The declaration has no variable name, since that is saved
-    #   in the innermost TypeDecl
-    # * The typename of the declaration is a list of type 
-    #   specifiers, and not a node. Here, basic identifier types
-    #   should be separated from more complex types like enums
-    #   and structs.
-    #
-    # This method fixes these problem.
-    #
-    def _fix_decl_name_type(self, decl, typename):
+        while modifier_tail.type: 
+            modifier_tail = modifier_tail.type
+        
+        # If the decl is a basic type, just tack the modifier onto
+        # it
+        #
+        if isinstance(decl, c_ast.TypeDecl):
+            modifier_tail.type = decl
+            return modifier
+        else:
+            # Otherwise, the decl is a list of modifiers. Reach
+            # its tail and splice the modifier onto the tail,
+            # pointing to the underlying basic type.
+            #
+            decl_tail = decl
+            
+            while not isinstance(decl_tail.type, c_ast.TypeDecl):
+                decl_tail = decl_tail.type
+            
+            modifier_tail.type = decl_tail.type
+            decl_tail.type = modifier_head
+            return decl
+
+    # Due to the order in which declarators are constructed,
+    # they have to be fixed in order to look like a normal AST.
+    # 
+    # When a declaration arrives from syntax construction, it has
+    # these problems:
+    # * The innermost TypeDecl has no type (because the basic
+    #   type is only known at the uppermost declaration level)
+    # * The declaration has no variable name, since that is saved
+    #   in the innermost TypeDecl
+    # * The typename of the declaration is a list of type 
+    #   specifiers, and not a node. Here, basic identifier types
+    #   should be separated from more complex types like enums
+    #   and structs.
+    #
+    # This method fixes these problem.
+    #
+    def _fix_decl_name_type(self, decl, typename):
         """ Fixes a declaration. Modifies decl.
-        """
-        # Reach the underlying basic type
-        #
-        type = decl
-        while not isinstance(type, c_ast.TypeDecl):
-            type = type.type
-        
-        decl.name = type.declname
-        type.quals = decl.quals
-        
-        # The typename is a list of types. If any type in this 
-        # list isn't a simple string type, it must be the only
-        # type in the list (it's illegal to declare "int enum .."
-        # If all the types are basic, they're collected in the
-        # IdentifierType holder.
-        #
-        for tn in typename:
-            if not isinstance(tn, StringType):
-                if len(typename) > 1:
-                    self._parse_error(
-                        "Invalid multiple types specified", tn.coord)
-                else:
-                    type.type = tn
-                    return decl
-        
-        type.type = c_ast.IdentifierType(typename)
+        """
+        # Reach the underlying basic type
+        #
+        type = decl
+        while not isinstance(type, c_ast.TypeDecl):
+            type = type.type
+        
+        decl.name = type.declname
+        type.quals = decl.quals
+        
+        # The typename is a list of types. If any type in this 
+        # list isn't a simple string type, it must be the only
+        # type in the list (it's illegal to declare "int enum .."
+        # If all the types are basic, they're collected in the
+        # IdentifierType holder.
+        #
+        for tn in typename:
+            if not isinstance(tn, StringType):
+                if len(typename) > 1:
+                    self._parse_error(
+                        "Invalid multiple types specified", tn.coord)
+                else:
+                    type.type = tn
+                    return decl
+        
+        type.type = c_ast.IdentifierType(typename)
         return decl
-    
-    def _add_declaration_specifier(self, declspec, newspec, kind):
-        """ Declaration specifiers are represented by a dictionary
-            with 3 entries:
-            * qual: a list of type qualifiers
-            * storage: a list of storage type qualifiers
-            * type: a list of type specifiers
-            
-            This method is given a declaration specifier, and a 
-            new specifier of a given kind.
-            Returns the declaration specifier, with the new 
-            specifier incorporated.
-        """
-        spec = declspec or dict(qual=[], storage=[], type=[])
-        spec[kind].append(newspec)
-        return spec
-    
-    def _build_function_definition(self, decl, spec, param_decls, body):
-        """ Builds a function definition.
-        """
-        declaration = c_ast.Decl(
-            name=None,
-            quals=spec['qual'],
-            storage=spec['storage'],
-            type=decl, 
-            init=None, 
-            bitsize=None, 
-            coord=decl.coord)
-        
-        typename = spec['type']
-        declaration = self._fix_decl_name_type(declaration, typename)
-        return c_ast.FuncDef(
-            decl=declaration,
-            param_decls=param_decls,
-            body=body,
-            coord=decl.coord)
-
+    
+    def _add_declaration_specifier(self, declspec, newspec, kind):
+        """ Declaration specifiers are represented by a dictionary
+            with 3 entries:
+            * qual: a list of type qualifiers
+            * storage: a list of storage type qualifiers
+            * type: a list of type specifiers
+            
+            This method is given a declaration specifier, and a 
+            new specifier of a given kind.
+            Returns the declaration specifier, with the new 
+            specifier incorporated.
+        """
+        spec = declspec or dict(qual=[], storage=[], type=[])
+        spec[kind].append(newspec)
+        return spec
+    
+    def _build_function_definition(self, decl, spec, param_decls, body):
+        """ Builds a function definition.
+        """
+        declaration = c_ast.Decl(
+            name=None,
+            quals=spec['qual'],
+            storage=spec['storage'],
+            type=decl, 
+            init=None, 
+            bitsize=None, 
+            coord=decl.coord)
+        
+        typename = spec['type']
+        declaration = self._fix_decl_name_type(declaration, typename)
+        return c_ast.FuncDef(
+            decl=declaration,
+            param_decls=param_decls,
+            body=body,
+            coord=decl.coord)
+
     def _select_struct_union_class(self, token):
-        """ Given a token (either STRUCT or UNION), selects the
+        """ Given a token (either STRUCT or UNION), selects the
             appropriate AST class.
-        """
-        if token == 'struct':
-            return c_ast.Struct
-        else:
-            return c_ast.Union
-
-    ##
-    ## Precedence and associativity of operators
-    ##
-    precedence = (
-        ('left', 'LOR'),
-        ('left', 'LAND'),
-        ('left', 'OR'),
-        ('left', 'XOR'),
-        ('left', 'AND'),
-        ('left', 'EQ', 'NE'),
-        ('left', 'GT', 'GE', 'LT', 'LE'),
-        ('left', 'RSHIFT', 'LSHIFT'),
-        ('left', 'PLUS', 'MINUS'),
-        ('left', 'TIMES', 'DIVIDE', 'MOD')
-    )
-    
-    ##
-    ## Grammar productions
-    ## Implementation of the BNF defined in K&R2 A.13
-    ##
+        """
+        if token == 'struct':
+            return c_ast.Struct
+        else:
+            return c_ast.Union
+
+    ##
+    ## Precedence and associativity of operators
+    ##
+    precedence = (
+        ('left', 'LOR'),
+        ('left', 'LAND'),
+        ('left', 'OR'),
+        ('left', 'XOR'),
+        ('left', 'AND'),
+        ('left', 'EQ', 'NE'),
+        ('left', 'GT', 'GE', 'LT', 'LE'),
+        ('left', 'RSHIFT', 'LSHIFT'),
+        ('left', 'PLUS', 'MINUS'),
+        ('left', 'TIMES', 'DIVIDE', 'MOD')
+    )
+    
+    ##
+    ## Grammar productions
+    ## Implementation of the BNF defined in K&R2 A.13
+    ##
     def p_translation_unit_1(self, p):
-        """ translation_unit    : external_declaration 
-        """
-        # Note: external_declaration is already a list
-        #
-        p[0] = c_ast.FileAST(p[1])
-    
+        """ translation_unit    : external_declaration 
+        """
+        # Note: external_declaration is already a list
+        #
+        p[0] = c_ast.FileAST(p[1])
+    
     def p_translation_unit_2(self, p):
         """ translation_unit    : translation_unit external_declaration
-        """
-        p[1].ext.extend(p[2])
-        p[0] = p[1]
-    
-    # Declarations always come as lists (because they can be
-    # several in one line), so we wrap the function definition 
-    # into a list as well, to make the return value of 
-    # external_declaration homogenous.
-    #
+        """
+        p[1].ext.extend(p[2])
+        p[0] = p[1]
+    
+    # Declarations always come as lists (because they can be
+    # several in one line), so we wrap the function definition 
+    # into a list as well, to make the return value of 
+    # external_declaration homogenous.
+    #
     def p_external_declaration_1(self, p):
-        """ external_declaration    : function_definition
-        """
-        p[0] = [p[1]]
-    
-    def p_external_declaration_2(self, p):
+        """ external_declaration    : function_definition
+        """
+        p[0] = [p[1]]
+    
+    def p_external_declaration_2(self, p):
         """ external_declaration    : declaration
-        """
-        p[0] = p[1]
-
+        """
+        p[0] = p[1]
+
     def p_external_declaration_3(self, p):
         """ external_declaration    : pp_directive
-        """
-        p[0] = p[1]
-
-    def p_pp_directive(self, p):
-        """ pp_directive  : PPHASH 
-        """
-        self._parse_error('Directives not supported yet', 
-            self._coord(p.lineno(1)))
-
-    # In function definitions, the declarator can be followed by
-    # a declaration list, for old "K&R style" function definitios.
-    #
+        """
+        p[0] = p[1]
+
+####################
+# Ruyk
+# Adding support for OpenMP 3.0
+
+    def p_pp_directive_1(self, p):
+        """ pp_directive  : PPHASH pragma_directive
+        """
+        p[0] = p[2]
+#        self._parse_error('Directives not supported yet', 
+#            self._coord(p.lineno(1)))
+
+    def p_pp_directive_2(self, p):
+        """ pp_directive  : PPHASH
+        """
+        self._parse_error('Directives not supported yet', 
+            self._coord(p.lineno(1)))
+
+    def p_pragma_directive(self, p):
+       """ pragma_directive : PRAGMA OMP """
+       p[0] = [c_ast.Pragma(
+            name='pragma', 
+            coord=self._coord(p.lineno(1)))]
+      # self._parse_error('Directives not supported yet', 
+      #     self._coord(p.lineno(1)))
+
+
+
+# End of OpenMP
+####################
+
+    # In function definitions, the declarator can be followed by
+    # a declaration list, for old "K&R style" function definitios.
+    #
     def p_function_definition_1(self, p):
         """ function_definition : declarator declaration_list_opt compound_statement
-        """
-        # no declaration specifiers
-        spec = dict(qual=[], storage=[], type=[])
-
-        p[0] = self._build_function_definition(
-            decl=p[1],
-            spec=spec, 
-            param_decls=p[2],
-            body=p[3])
-                    
-    def p_function_definition_2(self, p):
-        """ function_definition : declaration_specifiers declarator declaration_list_opt compound_statement
-        """
-        spec = p[1]
-
-        p[0] = self._build_function_definition(
-            decl=p[2],
-            spec=spec, 
-            param_decls=p[3],
-            body=p[4])
-        
+        """
+        # no declaration specifiers
+        spec = dict(qual=[], storage=[], type=[])
+
+        p[0] = self._build_function_definition(
+            decl=p[1],
+            spec=spec, 
+            param_decls=p[2],
+            body=p[3])
+                    
+    def p_function_definition_2(self, p):
+        """ function_definition : declaration_specifiers declarator declaration_list_opt compound_statement
+        """
+        spec = p[1]
+
+        p[0] = self._build_function_definition(
+            decl=p[2],
+            spec=spec, 
+            param_decls=p[3],
+            body=p[4])
+        
     def p_statement(self, p):
-        """ statement   : labeled_statement
-                        | expression_statement
-                        | compound_statement
-                        | selection_statement
-                        | iteration_statement    
-                        | jump_statement
-        """
-        p[0] = p[1]
-
-    # In C, declarations can come several in a line:
-    #   int x, *px, romulo = 5;
-    #
-    # However, for the AST, we will split them to separate Decl
-    # nodes.
-    #
-    # This rule splits its declarations and always returns a list
-    # of Decl nodes, even if it's one element long.
-    #
+        """ statement   : labeled_statement
+                        | expression_statement
+                        | compound_statement
+                        | selection_statement
+                        | iteration_statement    
+                        | jump_statement
+        """
+        p[0] = p[1]
+
+    def p_statement_1(self, p):
+        """ statement : pp_directive
+        """
+        p[0] = p[1][0]
+
+
+    # In C, declarations can come several in a line:
+    #   int x, *px, romulo = 5;
+    #
+    # However, for the AST, we will split them to separate Decl
+    # nodes.
+    #
+    # This rule splits its declarations and always returns a list
+    # of Decl nodes, even if it's one element long.
+    #
     def p_decl_body(self, p):
         """ decl_body : declaration_specifiers init_declarator_list_opt
-        """
-        spec = p[1]
-        is_typedef = 'typedef' in spec['storage']
-        decls = []
-
-        # p[2] (init_declarator_list_opt) is either a list or None
-        #
-        if p[2] is None:
-            # Then it's a declaration of a struct / enum tag,
-            # without an actual declarator.
-            #
-            type = spec['type']
-            if len(type) > 1:
-                coord = '?'
-                for t in type:
-                    if hasattr(t, 'coord'):
-                        coord = t.coord
-                        break
-                        
-                self._parse_error('Multiple type specifiers with a type tag', coord)
-            
-            decl = c_ast.Decl(
-                name=None,
-                quals=spec['qual'],
-                storage=spec['storage'],
-                type=type[0],
-                init=None,
-                bitsize=None,
-                coord=type[0].coord)
-            decls = [decl]
-        else:
-            for decl, init in p[2] or []:
-                if is_typedef:
-                    decl = c_ast.Typedef(
-                        name=None,
-                        quals=spec['qual'],
-                        storage=spec['storage'],
-                        type=decl,
-                        coord=decl.coord)
-                else:
-                    decl = c_ast.Decl(
-                        name=None,
-                        quals=spec['qual'],
-                        storage=spec['storage'],
-                        type=decl, 
-                        init=init, 
-                        bitsize=None, 
-                        coord=decl.coord)
-                
-                typename = spec['type']
-                fixed_decl = self._fix_decl_name_type(decl, typename)
-
-                # Add the type name defined by typedef to a
-                # symbol table (for usage in the lexer)
-                # 
-                if is_typedef:
-                    self._add_typedef_type(fixed_decl.name)
-
-                decls.append(fixed_decl)
-
-        p[0] = decls
-
-    # The declaration has been split to a decl_body sub-rule and
-    # SEMI, because having them in a single rule created a problem
-    # for defining typedefs.
-    #
-    # If a typedef line was directly followed by a line using the
-    # type defined with the typedef, the type would not be 
-    # recognized. This is because to reduce the declaration rule,
-    # the parser's lookahead asked for the token after SEMI, which
-    # was the type from the next line, and the lexer had no chance
-    # to see the updated type symbol table.
-    #
-    # Splitting solves this problem, because after seeing SEMI,
-    # the parser reduces decl_body, which actually adds the new
-    # type into the table to be seen by the lexer before the next
-    # line is reached.
-    #
+        """
+        spec = p[1]
+        is_typedef = 'typedef' in spec['storage']
+        decls = []
+
+        # p[2] (init_declarator_list_opt) is either a list or None
+        #
+        if p[2] is None:
+            # Then it's a declaration of a struct / enum tag,
+            # without an actual declarator.
+            #
+            type = spec['type']
+            if len(type) > 1:
+                coord = '?'
+                for t in type:
+                    if hasattr(t, 'coord'):
+                        coord = t.coord
+                        break
+                        
+                self._parse_error('Multiple type specifiers with a type tag', coord)
+            
+            decl = c_ast.Decl(
+                name=None,
+                quals=spec['qual'],
+                storage=spec['storage'],
+                type=type[0],
+                init=None,
+                bitsize=None,
+                coord=type[0].coord)
+            decls = [decl]
+        else:
+            for decl, init in p[2] or []:
+                if is_typedef:
+                    decl = c_ast.Typedef(
+                        name=None,
+                        quals=spec['qual'],
+                        storage=spec['storage'],
+                        type=decl,
+                        coord=decl.coord)
+                else:
+                    decl = c_ast.Decl(
+                        name=None,
+                        quals=spec['qual'],
+                        storage=spec['storage'],
+                        type=decl, 
+                        init=init, 
+                        bitsize=None, 
+                        coord=decl.coord)
+                
+                typename = spec['type']
+                fixed_decl = self._fix_decl_name_type(decl, typename)
+
+                # Add the type name defined by typedef to a
+                # symbol table (for usage in the lexer)
+                # 
+                if is_typedef:
+                    self._add_typedef_type(fixed_decl.name)
+
+                decls.append(fixed_decl)
+
+        p[0] = decls
+
+    # The declaration has been split to a decl_body sub-rule and
+    # SEMI, because having them in a single rule created a problem
+    # for defining typedefs.
+    #
+    # If a typedef line was directly followed by a line using the
+    # type defined with the typedef, the type would not be 
+    # recognized. This is because to reduce the declaration rule,
+    # the parser's lookahead asked for the token after SEMI, which
+    # was the type from the next line, and the lexer had no chance
+    # to see the updated type symbol table.
+    #
+    # Splitting solves this problem, because after seeing SEMI,
+    # the parser reduces decl_body, which actually adds the new
+    # type into the table to be seen by the lexer before the next
+    # line is reached.
+    #
     def p_declaration(self, p):
-        """ declaration : decl_body SEMI 
-        """
-        p[0] = p[1]
-
-    # Since each declaration is a list of declarations, this
-    # rule will combine all the declarations and return a single
-    # list
-    # 
+        """ declaration : decl_body SEMI 
+        """
+        p[0] = p[1]
+
+    # Since each declaration is a list of declarations, this
+    # rule will combine all the declarations and return a single
+    # list
+    # 
     def p_declaration_list(self, p):
-        """ declaration_list    : declaration
+        """ declaration_list    : declaration
                                 | declaration_list declaration
-        """
-        p[0] = p[1] if len(p) == 2 else p[1] + p[2]
-    
-    def p_declaration_specifiers_1(self, p):
-        """ declaration_specifiers  : type_qualifier declaration_specifiers_opt 
-        """
-        p[0] = self._add_declaration_specifier(p[2], p[1], 'qual')
-        
+        """
+        p[0] = p[1] if len(p) == 2 else p[1] + p[2]
+    
+    def p_declaration_specifiers_1(self, p):
+        """ declaration_specifiers  : type_qualifier declaration_specifiers_opt 
+        """
+        p[0] = self._add_declaration_specifier(p[2], p[1], 'qual')
+        
     def p_declaration_specifiers_2(self, p):
-        """ declaration_specifiers  : type_specifier declaration_specifiers_opt
-        """
-        p[0] = self._add_declaration_specifier(p[2], p[1], 'type')
-        
-    def p_declaration_specifiers_3(self, p):
-        """ declaration_specifiers  : storage_class_specifier declaration_specifiers_opt
-        """
-        p[0] = self._add_declaration_specifier(p[2], p[1], 'storage')
-        
+        """ declaration_specifiers  : type_specifier declaration_specifiers_opt
+        """
+        p[0] = self._add_declaration_specifier(p[2], p[1], 'type')
+        
+    def p_declaration_specifiers_3(self, p):
+        """ declaration_specifiers  : storage_class_specifier declaration_specifiers_opt
+        """
+        p[0] = self._add_declaration_specifier(p[2], p[1], 'storage')
+        
     def p_storage_class_specifier(self, p):
-        """ storage_class_specifier : AUTO
-                                    | REGISTER
-                                    | STATIC
-                                    | EXTERN
+        """ storage_class_specifier : AUTO
+                                    | REGISTER
+                                    | STATIC
+                                    | EXTERN
                                     | TYPEDEF
-        """
-        p[0] = p[1]
-        
+        """
+        p[0] = p[1]
+        
     def p_type_specifier_1(self, p):
-        """ type_specifier  : VOID
-                            | CHAR
-                            | SHORT
-                            | INT
-                            | LONG
-                            | FLOAT
-                            | DOUBLE
-                            | SIGNED
-                            | UNSIGNED
-                            | typedef_name
-                            | enum_specifier
-                            | struct_or_union_specifier
-        """
-        p[0] = p[1]
-    
+        """ type_specifier  : VOID
+                            | CHAR
+                            | SHORT
+                            | INT
+                            | LONG
+                            | FLOAT
+                            | DOUBLE
+                            | SIGNED
+                            | UNSIGNED
+                            | typedef_name
+                            | enum_specifier
+                            | struct_or_union_specifier
+        """
+        p[0] = p[1]
+    
     def p_type_qualifier(self, p):
-        """ type_qualifier  : CONST
+        """ type_qualifier  : CONST
                             | VOLATILE
-        """
-        p[0] = p[1]
-    
+        """
+        p[0] = p[1]
+    
     def p_init_declarator_list(self, p):
-        """ init_declarator_list    : init_declarator
+        """ init_declarator_list    : init_declarator
                                     | init_declarator_list COMMA init_declarator
-        """
-        p[0] = p[1] + [p[3]] if len(p) == 4 else [p[1]]
-
-    # Returns a (declarator, intializer) pair
-    # If there's no initializer, returns (declarator, None)
-    #
+        """
+        p[0] = p[1] + [p[3]] if len(p) == 4 else [p[1]]
+
+    # Returns a (declarator, intializer) pair
+    # If there's no initializer, returns (declarator, None)
+    #
     def p_init_declarator(self, p):
-        """ init_declarator : declarator
+        """ init_declarator : declarator
                             | declarator EQUALS initializer
-        """
-        p[0] = (p[1], p[3] if len(p) > 2 else None)        
-    
-    def p_specifier_qualifier_list_1(self, p):
-        """ specifier_qualifier_list    : type_qualifier specifier_qualifier_list_opt
-        """
-        p[0] = self._add_declaration_specifier(p[2], p[1], 'qual')
-        
+        """
+        p[0] = (p[1], p[3] if len(p) > 2 else None)        
+    
+    def p_specifier_qualifier_list_1(self, p):
+        """ specifier_qualifier_list    : type_qualifier specifier_qualifier_list_opt
+        """
+        p[0] = self._add_declaration_specifier(p[2], p[1], 'qual')
+        
     def p_specifier_qualifier_list_2(self, p):
-        """ specifier_qualifier_list    : type_specifier specifier_qualifier_list_opt
-        """
-        p[0] = self._add_declaration_specifier(p[2], p[1], 'type')
-
-    # TYPEID is allowed here (and in other struct/enum related tag names), because
-    # struct/enum tags reside in their own namespace and can be named the same as types
-    #
+        """ specifier_qualifier_list    : type_specifier specifier_qualifier_list_opt
+        """
+        p[0] = self._add_declaration_specifier(p[2], p[1], 'type')
+
+    # TYPEID is allowed here (and in other struct/enum related tag names), because
+    # struct/enum tags reside in their own namespace and can be named the same as types
+    #
     def p_struct_or_union_specifier_1(self, p):
-        """ struct_or_union_specifier   : struct_or_union ID
+        """ struct_or_union_specifier   : struct_or_union ID
                                         | struct_or_union TYPEID
-        """
-        klass = self._select_struct_union_class(p[1])
-        p[0] = klass(
-            name=p[2], 
-            decls=None, 
-            coord=self._coord(p.lineno(2)))
-
+        """
+        klass = self._select_struct_union_class(p[1])
+        p[0] = klass(
+            name=p[2], 
+            decls=None, 
+            coord=self._coord(p.lineno(2)))
+
     def p_struct_or_union_specifier_2(self, p):
         """ struct_or_union_specifier : struct_or_union LBRACE struct_declaration_list RBRACE
-        """
-        klass = self._select_struct_union_class(p[1])
-        p[0] = klass(
-            name=None,
-            decls=p[3],
-            coord=self._coord(p.lineno(2)))
-
-    def p_struct_or_union_specifier_3(self, p):
-        """ struct_or_union_specifier   : struct_or_union ID LBRACE struct_declaration_list RBRACE
-                                        | struct_or_union TYPEID LBRACE struct_declaration_list RBRACE
-        """
-        klass = self._select_struct_union_class(p[1])
-        p[0] = klass(
-            name=p[2],
-            decls=p[4],
-            coord=self._coord(p.lineno(2)))
-
+        """
+        klass = self._select_struct_union_class(p[1])
+        p[0] = klass(
+            name=None,
+            decls=p[3],
+            coord=self._coord(p.lineno(2)))
+
+    def p_struct_or_union_specifier_3(self, p):
+        """ struct_or_union_specifier   : struct_or_union ID LBRACE struct_declaration_list RBRACE
+                                        | struct_or_union TYPEID LBRACE struct_declaration_list RBRACE
+        """
+        klass = self._select_struct_union_class(p[1])
+        p[0] = klass(
+            name=p[2],
+            decls=p[4],
+            coord=self._coord(p.lineno(2)))
+
     def p_struct_or_union(self, p):
-        """ struct_or_union : STRUCT 
+        """ struct_or_union : STRUCT 
                             | UNION
-        """
-        p[0] = p[1]
-
-    # Combine all declarations into a single list
-    #
+        """
+        p[0] = p[1]
+
+    # Combine all declarations into a single list
+    #
     def p_struct_declaration_list(self, p):
-        """ struct_declaration_list     : struct_declaration
+        """ struct_declaration_list     : struct_declaration
                                         | struct_declaration_list struct_declaration
-        """
-        p[0] = p[1] if len(p) == 2 else p[1] + p[2]
-
+        """
+        p[0] = p[1] if len(p) == 2 else p[1] + p[2]
+
     def p_struct_declaration_1(self, p):
         """ struct_declaration : specifier_qualifier_list struct_declarator_list SEMI
-        """
-        spec = p[1]
-        decls = []
-        
-        for struct_decl in p[2]:
-            decl = c_ast.Decl(
-                name=None,
-                quals=spec['qual'],
-                storage=spec['storage'],
-                type=struct_decl['decl'],
-                init=None,
-                bitsize=struct_decl['bitsize'],
-                coord=struct_decl['decl'].coord)
-            
-            typename = spec['type']
-            decls.append(self._fix_decl_name_type(decl, typename))
-        
-        p[0] = decls
-    
+        """
+        spec = p[1]
+        decls = []
+        
+        for struct_decl in p[2]:
+            decl = c_ast.Decl(
+                name=None,
+                quals=spec['qual'],
+                storage=spec['storage'],
+                type=struct_decl['decl'],
+                init=None,
+                bitsize=struct_decl['bitsize'],
+                coord=struct_decl['decl'].coord)
+            
+            typename = spec['type']
+            decls.append(self._fix_decl_name_type(decl, typename))
+        
+        p[0] = decls
+    
     def p_struct_declarator_list(self, p):
-        """ struct_declarator_list  : struct_declarator
+        """ struct_declarator_list  : struct_declarator
                                     | struct_declarator_list COMMA struct_declarator
-        """
-        p[0] = p[1] + [p[3]] if len(p) == 4 else [p[1]]
-    
-    # struct_declarator passes up a dict with the keys: decl (for
-    # the underlying declarator) and bitsize (for the bitsize)
-    #
+        """
+        p[0] = p[1] + [p[3]] if len(p) == 4 else [p[1]]
+    
+    # struct_declarator passes up a dict with the keys: decl (for
+    # the underlying declarator) and bitsize (for the bitsize)
+    #
     def p_struct_declarator_1(self, p):
         """ struct_declarator : declarator
-        """
-        p[0] = {'decl': p[1], 'bitsize': None}
-    
+        """
+        p[0] = {'decl': p[1], 'bitsize': None}
+    
     def p_struct_declarator_2(self, p):
-        """ struct_declarator   : declarator COLON constant_expression
+        """ struct_declarator   : declarator COLON constant_expression
                                 | COLON constant_expression
-        """
-        if len(p) > 3:
-            p[0] = {'decl': p[1], 'bitsize': p[3]}
-        else:
-            p[0] = {'decl': None, 'bitsize': p[2]}
-    
+        """
+        if len(p) > 3:
+            p[0] = {'decl': p[1], 'bitsize': p[3]}
+        else:
+            p[0] = {'decl': None, 'bitsize': p[2]}
+    
     def p_enum_specifier_1(self, p):
-        """ enum_specifier  : ENUM ID
-                            | ENUM TYPEID
-        """
-        p[0] = c_ast.Enum(p[2], None, self._coord(p.lineno(1)))
-    
-    def p_enum_specifier_2(self, p):
-        """ enum_specifier  : ENUM LBRACE enumerator_list RBRACE
-        """
-        p[0] = c_ast.Enum(None, p[3], self._coord(p.lineno(1)))
-    
-    def p_enum_specifier_3(self, p):
-        """ enum_specifier  : ENUM ID LBRACE enumerator_list RBRACE
-                            | ENUM TYPEID LBRACE enumerator_list RBRACE
-        """
-        p[0] = c_ast.Enum(p[2], p[4], self._coord(p.lineno(1)))
-        
+        """ enum_specifier  : ENUM ID
+                            | ENUM TYPEID
+        """
+        p[0] = c_ast.Enum(p[2], None, self._coord(p.lineno(1)))
+    
+    def p_enum_specifier_2(self, p):
+        """ enum_specifier  : ENUM LBRACE enumerator_list RBRACE
+        """
+        p[0] = c_ast.Enum(None, p[3], self._coord(p.lineno(1)))
+    
+    def p_enum_specifier_3(self, p):
+        """ enum_specifier  : ENUM ID LBRACE enumerator_list RBRACE
+                            | ENUM TYPEID LBRACE enumerator_list RBRACE
+        """
+        p[0] = c_ast.Enum(p[2], p[4], self._coord(p.lineno(1)))
+        
     def p_enumerator_list(self, p):
-        """ enumerator_list : enumerator
-                            | enumerator_list COMMA
+        """ enumerator_list : enumerator
+                            | enumerator_list COMMA
                             | enumerator_list COMMA enumerator
-        """
-        if len(p) == 2:
-            p[0] = c_ast.EnumeratorList([p[1]], p[1].coord)
-        elif len(p) == 3:
-            p[0] = p[1]
-        else:
-            p[1].enumerators.append(p[3])
-            p[0] = p[1]
-
+        """
+        if len(p) == 2:
+            p[0] = c_ast.EnumeratorList([p[1]], p[1].coord)
+        elif len(p) == 3:
+            p[0] = p[1]
+        else:
+            p[1].enumerators.append(p[3])
+            p[0] = p[1]
+
     def p_enumerator(self, p):
-        """ enumerator  : ID
+        """ enumerator  : ID
                         | ID EQUALS constant_expression
-        """
-        if len(p) == 2:
-            p[0] = c_ast.Enumerator(
-                        p[1], None, 
-                        self._coord(p.lineno(1)))
-        else:
-            p[0] = c_ast.Enumerator(
-                        p[1], p[3], 
-                        self._coord(p.lineno(1)))
-    
+        """
+        if len(p) == 2:
+            p[0] = c_ast.Enumerator(
+                        p[1], None, 
+                        self._coord(p.lineno(1)))
+        else:
+            p[0] = c_ast.Enumerator(
+                        p[1], p[3], 
+                        self._coord(p.lineno(1)))
+    
     def p_declarator_1(self, p):
-        """ declarator  : direct_declarator 
-        """
-        p[0] = p[1]
-    
+        """ declarator  : direct_declarator 
+        """
+        p[0] = p[1]
+    
     def p_declarator_2(self, p):
-        """ declarator  : pointer direct_declarator 
-        """
-        p[0] = self._type_modify_decl(p[2], p[1])
-    
+        """ declarator  : pointer direct_declarator 
+        """
+        p[0] = self._type_modify_decl(p[2], p[1])
+    
     def p_direct_declarator_1(self, p):
-        """ direct_declarator   : ID 
-        """
-        p[0] = c_ast.TypeDecl(
-            declname=p[1], 
-            type=None, 
-            quals=None,
-            coord=self._coord(p.lineno(1)))
-        
-    def p_direct_declarator_2(self, p):
-        """ direct_declarator   : LPAREN declarator RPAREN 
-        """
-        p[0] = p[2]
-        
-    def p_direct_declarator_3(self, p):
-        """ direct_declarator   : direct_declarator LBRACKET constant_expression_opt RBRACKET 
-        """
-        arr = c_ast.ArrayDecl(
-            type=None,
-            dim=p[3],
-            coord=p[1].coord)
-        
-        p[0] = self._type_modify_decl(decl=p[1], modifier=arr)
-
-    def p_direct_declarator_4(self, p):
-        """ direct_declarator   : direct_declarator LPAREN parameter_type_list RPAREN 
-                                | direct_declarator LPAREN identifier_list_opt RPAREN
-        """
-        func = c_ast.FuncDecl(
-            args=p[3],
-            type=None,
-            coord=p[1].coord)
-        
-        p[0] = self._type_modify_decl(decl=p[1], modifier=func)
-    
+        """ direct_declarator   : ID 
+        """
+        p[0] = c_ast.TypeDecl(
+            declname=p[1], 
+            type=None, 
+            quals=None,
+            coord=self._coord(p.lineno(1)))
+        
+    def p_direct_declarator_2(self, p):
+        """ direct_declarator   : LPAREN declarator RPAREN 
+        """
+        p[0] = p[2]
+        
+    def p_direct_declarator_3(self, p):
+        """ direct_declarator   : direct_declarator LBRACKET constant_expression_opt RBRACKET 
+        """
+        arr = c_ast.ArrayDecl(
+            type=None,
+            dim=p[3],
+            coord=p[1].coord)
+        
+        p[0] = self._type_modify_decl(decl=p[1], modifier=arr)
+
+    def p_direct_declarator_4(self, p):
+        """ direct_declarator   : direct_declarator LPAREN parameter_type_list RPAREN 
+                                | direct_declarator LPAREN identifier_list_opt RPAREN
+        """
+        func = c_ast.FuncDecl(
+            args=p[3],
+            type=None,
+            coord=p[1].coord)
+        
+        p[0] = self._type_modify_decl(decl=p[1], modifier=func)
+    
     def p_pointer(self, p):
-        """ pointer : TIMES type_qualifier_list_opt
+        """ pointer : TIMES type_qualifier_list_opt
                     | TIMES type_qualifier_list_opt pointer
-        """
-        coord = self._coord(p.lineno(1))
-        
-        p[0] = c_ast.PtrDecl(
-            quals=p[2] or [],
-            type=p[3] if len(p) > 3 else None,
-                coord=coord)
-    
+        """
+        coord = self._coord(p.lineno(1))
+        
+        p[0] = c_ast.PtrDecl(
+            quals=p[2] or [],
+            type=p[3] if len(p) > 3 else None,
+                coord=coord)
+    
     def p_type_qualifier_list(self, p):
-        """ type_qualifier_list : type_qualifier
+        """ type_qualifier_list : type_qualifier
                                 | type_qualifier_list type_qualifier
-        """
-        p[0] = [p[1]] if len(p) == 2 else p[1] + [p[2]]
-    
-    def p_parameter_type_list(self, p):
-        """ parameter_type_list : parameter_list
-                                | parameter_list COMMA ELLIPSIS
-        """
-        if len(p) > 2: 
-            p[1].params.append(c_ast.EllipsisParam())
-        
-        p[0] = p[1]
-
+        """
+        p[0] = [p[1]] if len(p) == 2 else p[1] + [p[2]]
+    
+    def p_parameter_type_list(self, p):
+        """ parameter_type_list : parameter_list
+                                | parameter_list COMMA ELLIPSIS
+        """
+        if len(p) > 2: 
+            p[1].params.append(c_ast.EllipsisParam())
+        
+        p[0] = p[1]
+
     def p_parameter_list(self, p):
-        """ parameter_list  : parameter_declaration
+        """ parameter_list  : parameter_declaration
                             | parameter_list COMMA parameter_declaration
-        """
-        if len(p) == 2: # single parameter
-            p[0] = c_ast.ParamList([p[1]], p[1].coord)
-        else:
-            p[1].params.append(p[3])
-            p[0] = p[1]
-
+        """
+        if len(p) == 2: # single parameter
+            p[0] = c_ast.ParamList([p[1]], p[1].coord)
+        else:
+            p[1].params.append(p[3])
+            p[0] = p[1]
+
     def p_parameter_declaration_1(self, p):
-        """ parameter_declaration   : declaration_specifiers declarator
-        """
-        spec = p[1]
-        decl = p[2]
-        
-        decl = c_ast.Decl(
-            name=None,
-            quals=spec['qual'],
-            storage=spec['storage'],
-            type=decl, 
-            init=None, 
-            bitsize=None, 
-            coord=decl.coord)
-        
-        typename = spec['type'] or ['int']
-        p[0] = self._fix_decl_name_type(decl, typename)
-        
+        """ parameter_declaration   : declaration_specifiers declarator
+        """
+        spec = p[1]
+        decl = p[2]
+        
+        decl = c_ast.Decl(
+            name=None,
+            quals=spec['qual'],
+            storage=spec['storage'],
+            type=decl, 
+            init=None, 
+            bitsize=None, 
+            coord=decl.coord)
+        
+        typename = spec['type'] or ['int']
+        p[0] = self._fix_decl_name_type(decl, typename)
+        
     def p_parameter_declaration_2(self, p):
         """ parameter_declaration   : declaration_specifiers abstract_declarator_opt
-        """
-        spec = p[1]
-        decl = c_ast.Typename(
-            quals=spec['qual'], 
-            type=p[2] or c_ast.TypeDecl(None, None, None))
-            
-        typename = spec['type'] or ['int']
-        
-        p[0] = self._fix_decl_name_type(decl, typename)        
-    
+        """
+        spec = p[1]
+        decl = c_ast.Typename(
+            quals=spec['qual'], 
+            type=p[2] or c_ast.TypeDecl(None, None, None))
+            
+        typename = spec['type'] or ['int']
+        
+        p[0] = self._fix_decl_name_type(decl, typename)        
+    
     def p_identifier_list(self, p):
-        """ identifier_list : identifier
+        """ identifier_list : identifier
                             | identifier_list COMMA identifier
-        """
-        if len(p) == 2: # single parameter
-            p[0] = c_ast.ParamList([p[1]], p[1].coord)
-        else:
-            p[1].params.append(p[3])
-            p[0] = p[1]
-
+        """
+        if len(p) == 2: # single parameter
+            p[0] = c_ast.ParamList([p[1]], p[1].coord)
+        else:
+            p[1].params.append(p[3])
+            p[0] = p[1]
+
     def p_initializer_1(self, p):
         """ initializer : assignment_expression
-        """
-        p[0] = p[1]
-    
+        """
+        p[0] = p[1]
+    
     def p_initializer_2(self, p):
-        """ initializer : LBRACE initializer_list RBRACE
+        """ initializer : LBRACE initializer_list RBRACE
                         | LBRACE initializer_list COMMA RBRACE
-        """
-        p[0] = p[2]
-
+        """
+        p[0] = p[2]
+
     def p_initializer_list(self, p):
-        """ initializer_list    : initializer
-                                | initializer_list COMMA initializer
-        """
-        if len(p) == 2: # single initializer
-            p[0] = c_ast.ExprList([p[1]], p[1].coord)
-        else:
-            p[1].exprs.append(p[3])
-            p[0] = p[1]
-        
+        """ initializer_list    : initializer
+                                | initializer_list COMMA initializer
+        """
+        if len(p) == 2: # single initializer
+            p[0] = c_ast.ExprList([p[1]], p[1].coord)
+        else:
+            p[1].exprs.append(p[3])
+            p[0] = p[1]
+        
     def p_type_name(self, p):
-        """ type_name   : specifier_qualifier_list abstract_declarator_opt 
-        """
-        #~ print '=========='
-        #~ print p[1]
-        #~ print p[2]
-        #~ print p[2].children()
-        #~ print '=========='
-        
-        typename = c_ast.Typename(
-            quals=p[1]['qual'], 
-            type=p[2] or c_ast.TypeDecl(None, None, None))
-        
-        p[0] = self._fix_decl_name_type(typename, p[1]['type'])
-
+        """ type_name   : specifier_qualifier_list abstract_declarator_opt 
+        """
+        #~ print '=========='
+        #~ print p[1]
+        #~ print p[2]
+        #~ print p[2].children()
+        #~ print '=========='
+        
+        typename = c_ast.Typename(
+            quals=p[1]['qual'], 
+            type=p[2] or c_ast.TypeDecl(None, None, None))
+        
+        p[0] = self._fix_decl_name_type(typename, p[1]['type'])
+
     def p_abstract_declarator_1(self, p):
-        """ abstract_declarator     : pointer
-        """
-        dummytype = c_ast.TypeDecl(None, None, None)
-        p[0] = self._type_modify_decl(
-            decl=dummytype, 
-            modifier=p[1])
-        
+        """ abstract_declarator     : pointer
+        """
+        dummytype = c_ast.TypeDecl(None, None, None)
+        p[0] = self._type_modify_decl(
+            decl=dummytype, 
+            modifier=p[1])
+        
     def p_abstract_declarator_2(self, p):
-        """ abstract_declarator     : pointer direct_abstract_declarator
-        """
-        p[0] = self._type_modify_decl(p[2], p[1])
-        
+        """ abstract_declarator     : pointer direct_abstract_declarator
+        """
+        p[0] = self._type_modify_decl(p[2], p[1])
+        
     def p_abstract_declarator_3(self, p):
         """ abstract_declarator     : direct_abstract_declarator
-        """
-        p[0] = p[1]
-    
-    # Creating and using direct_abstract_declarator_opt here 
-    # instead of listing both direct_abstract_declarator and the
-    # lack of it in the beginning of _1 and _2 caused two 
-    # shift/reduce errors.
-    #
+        """
+        p[0] = p[1]
+    
+    # Creating and using direct_abstract_declarator_opt here 
+    # instead of listing both direct_abstract_declarator and the
+    # lack of it in the beginning of _1 and _2 caused two 
+    # shift/reduce errors.
+    #
     def p_direct_abstract_declarator_1(self, p):
-        """ direct_abstract_declarator  : LPAREN abstract_declarator RPAREN """
-        p[0] = p[2]
-    
+        """ direct_abstract_declarator  : LPAREN abstract_declarator RPAREN """
+        p[0] = p[2]
+    
     def p_direct_abstract_declarator_2(self, p):
-        """ direct_abstract_declarator  : direct_abstract_declarator LBRACKET constant_expression_opt RBRACKET 
-        """
-        arr = c_ast.ArrayDecl(
-            type=None,
-            dim=p[3],
-            coord=p[1].coord)
-        
-        p[0] = self._type_modify_decl(decl=p[1], modifier=arr)
-        
-    def p_direct_abstract_declarator_3(self, p):
-        """ direct_abstract_declarator  : LBRACKET constant_expression_opt RBRACKET 
-        """
-        p[0] = c_ast.ArrayDecl(
-            type=c_ast.TypeDecl(None, None, None),
-            dim=p[2],
-            coord=self._coord(p.lineno(1)))
-        
+        """ direct_abstract_declarator  : direct_abstract_declarator LBRACKET constant_expression_opt RBRACKET 
+        """
+        arr = c_ast.ArrayDecl(
+            type=None,
+            dim=p[3],
+            coord=p[1].coord)
+        
+        p[0] = self._type_modify_decl(decl=p[1], modifier=arr)
+        
+    def p_direct_abstract_declarator_3(self, p):
+        """ direct_abstract_declarator  : LBRACKET constant_expression_opt RBRACKET 
+        """
+        p[0] = c_ast.ArrayDecl(
+            type=c_ast.TypeDecl(None, None, None),
+            dim=p[2],
+            coord=self._coord(p.lineno(1)))
+        
     def p_direct_abstract_declarator_4(self, p):
-        """ direct_abstract_declarator  : direct_abstract_declarator LPAREN parameter_type_list_opt RPAREN 
-        """
-        func = c_ast.FuncDecl(
-            args=p[3],
-            type=None,
-            coord=p[1].coord)
-        
-        p[0] = self._type_modify_decl(decl=p[1], modifier=func)
-        
-    def p_direct_abstract_declarator_5(self, p):
-        """ direct_abstract_declarator  : LPAREN parameter_type_list_opt RPAREN 
-        """
-        p[0] = c_ast.FuncDecl(
-            args=p[2],
-            type=c_ast.TypeDecl(None, None, None),
-            coord=p[1].coord)
-        
+        """ direct_abstract_declarator  : direct_abstract_declarator LPAREN parameter_type_list_opt RPAREN 
+        """
+        func = c_ast.FuncDecl(
+            args=p[3],
+            type=None,
+            coord=p[1].coord)
+        
+        p[0] = self._type_modify_decl(decl=p[1], modifier=func)
+        
+    def p_direct_abstract_declarator_5(self, p):
+        """ direct_abstract_declarator  : LPAREN parameter_type_list_opt RPAREN 
+        """
+        p[0] = c_ast.FuncDecl(
+            args=p[2],
+            type=c_ast.TypeDecl(None, None, None),
+            coord=p[1].coord)
+        
     def p_compound_statement_1(self, p):
-        """ compound_statement : LBRACE statement_list_opt RBRACE """
-        p[0] = c_ast.Compound(
-            decls=None, 
-            stmts=p[2], 
-            coord=self._coord(p.lineno(1)))
-    
-    def p_compound_statement_2(self, p):
-        """ compound_statement : LBRACE declaration_list RBRACE """
-        p[0] = c_ast.Compound(
-            decls=p[2], 
-            stmts=None, 
-            coord=self._coord(p.lineno(1)))
-    
-    def p_compound_statement_3(self, p):
-        """ compound_statement : LBRACE declaration_list statement_list RBRACE """
-        #~ print '(((((('
-        #~ print p[2]
-        #~ print p[3]
-        #~ print '(((((('
-        p[0] = c_ast.Compound(
-            decls=p[2], 
-            stmts=p[3], 
-            coord=self._coord(p.lineno(1)))
-    
-    # Note: this doesn't create an AST node, but a list of AST 
-    # nodes that will be used as the statement list of a compound
-    #
+        """ compound_statement : LBRACE statement_list_opt RBRACE """
+        p[0] = c_ast.Compound(
+            decls=None, 
+            stmts=p[2], 
+            coord=self._coord(p.lineno(1)))
+    
+    def p_compound_statement_2(self, p):
+        """ compound_statement : LBRACE declaration_list RBRACE """
+        p[0] = c_ast.Compound(
+            decls=p[2], 
+            stmts=None, 
+            coord=self._coord(p.lineno(1)))
+    
+    def p_compound_statement_3(self, p):
+        """ compound_statement : LBRACE declaration_list statement_list RBRACE """
+        #~ print '(((((('
+        #~ print p[2]
+        #~ print p[3]
+        #~ print '(((((('
+        p[0] = c_ast.Compound(
+            decls=p[2], 
+            stmts=p[3], 
+            coord=self._coord(p.lineno(1)))
+    
+    # Note: this doesn't create an AST node, but a list of AST 
+    # nodes that will be used as the statement list of a compound
+    #
     def p_statement_list(self, p):
-        """ statement_list  : statement 
-                            | statement_list statement
-        """
-        if len(p) == 2: # single expr
-            p[0] = [p[1]] if p[1] else [] 
-        else:
-            p[0] = p[1] + ([p[2]] if p[2] else [])
-    
+        """ statement_list  : statement 
+                            | statement_list statement
+        """
+        if len(p) == 2: # single expr
+            p[0] = [p[1]] if p[1] else [] 
+        else:
+            p[0] = p[1] + ([p[2]] if p[2] else [])
+    
     def p_labeled_statement_1(self, p):
-        """ labeled_statement : ID COLON statement """
-        p[0] = c_ast.Label(p[1], p[3], self._coord(p.lineno(1)))
-    
-    def p_labeled_statement_2(self, p):
-        """ labeled_statement : CASE constant_expression COLON statement """
-        p[0] = c_ast.Case(p[2], p[4], self._coord(p.lineno(1)))
-        
-    def p_labeled_statement_3(self, p):
-        """ labeled_statement : DEFAULT COLON statement """
-        p[0] = c_ast.Default(p[3], self._coord(p.lineno(1)))
-        
+        """ labeled_statement : ID COLON statement """
+        p[0] = c_ast.Label(p[1], p[3], self._coord(p.lineno(1)))
+    
+    def p_labeled_statement_2(self, p):
+        """ labeled_statement : CASE constant_expression COLON statement """
+        p[0] = c_ast.Case(p[2], p[4], self._coord(p.lineno(1)))
+        
+    def p_labeled_statement_3(self, p):
+        """ labeled_statement : DEFAULT COLON statement """
+        p[0] = c_ast.Default(p[3], self._coord(p.lineno(1)))
+        
     def p_selection_statement_1(self, p):
-        """ selection_statement : IF LPAREN expression RPAREN statement """
-        p[0] = c_ast.If(p[3], p[5], None, self._coord(p.lineno(1)))
-    
+        """ selection_statement : IF LPAREN expression RPAREN statement """
+        p[0] = c_ast.If(p[3], p[5], None, self._coord(p.lineno(1)))
+    
     def p_selection_statement_2(self, p):
-        """ selection_statement : IF LPAREN expression RPAREN statement ELSE statement """
-        p[0] = c_ast.If(p[3], p[5], p[7], self._coord(p.lineno(1)))
-    
+        """ selection_statement : IF LPAREN expression RPAREN statement ELSE statement """
+        p[0] = c_ast.If(p[3], p[5], p[7], self._coord(p.lineno(1)))
+    
     def p_selection_statement_3(self, p):
-        """ selection_statement : SWITCH LPAREN expression RPAREN statement """
-        p[0] = c_ast.Switch(p[3], p[5], self._coord(p.lineno(1)))
-    
+        """ selection_statement : SWITCH LPAREN expression RPAREN statement """
+        p[0] = c_ast.Switch(p[3], p[5], self._coord(p.lineno(1)))
+    
     def p_iteration_statement_1(self, p):
-        """ iteration_statement : WHILE LPAREN expression RPAREN statement """
-        p[0] = c_ast.While(p[3], p[5], self._coord(p.lineno(1)))
-    
+        """ iteration_statement : WHILE LPAREN expression RPAREN statement """
+        p[0] = c_ast.While(p[3], p[5], self._coord(p.lineno(1)))
+    
     def p_iteration_statement_2(self, p):
-        """ iteration_statement : DO statement WHILE LPAREN expression RPAREN """
-        p[0] = c_ast.DoWhile(p[5], p[2], self._coord(p.lineno(1)))
-    
+        """ iteration_statement : DO statement WHILE LPAREN expression RPAREN """
+        p[0] = c_ast.DoWhile(p[5], p[2], self._coord(p.lineno(1)))
+    
     def p_iteration_statement_3(self, p):
-        """ iteration_statement : FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement """
-        p[0] = c_ast.For(p[3], p[5], p[7], p[9], self._coord(p.lineno(1)))
-    
+        """ iteration_statement : FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement """
+        p[0] = c_ast.For(p[3], p[5], p[7], p[9], self._coord(p.lineno(1)))
+    
     def p_jump_statement_1(self, p):
-        """ jump_statement  : GOTO ID SEMI """
-        p[0] = c_ast.Goto(p[2], self._coord(p.lineno(1)))
-    
-    def p_jump_statement_2(self, p):
-        """ jump_statement  : BREAK SEMI """
-        p[0] = c_ast.Break(self._coord(p.lineno(1)))
-    
-    def p_jump_statement_3(self, p):
-        """ jump_statement  : CONTINUE SEMI """
-        p[0] = c_ast.Continue(self._coord(p.lineno(1)))
-        
-    def p_jump_statement_4(self, p):
-        """ jump_statement  : RETURN expression SEMI  
-                            | RETURN SEMI 
-        """
-        p[0] = c_ast.Return(p[2] if len(p) == 4 else None, self._coord(p.lineno(1)))
-    
+        """ jump_statement  : GOTO ID SEMI """
+        p[0] = c_ast.Goto(p[2], self._coord(p.lineno(1)))
+    
+    def p_jump_statement_2(self, p):
+        """ jump_statement  : BREAK SEMI """
+        p[0] = c_ast.Break(self._coord(p.lineno(1)))
+    
+    def p_jump_statement_3(self, p):
+        """ jump_statement  : CONTINUE SEMI """
+        p[0] = c_ast.Continue(self._coord(p.lineno(1)))
+        
+    def p_jump_statement_4(self, p):
+        """ jump_statement  : RETURN expression SEMI  
+                            | RETURN SEMI 
+        """
+        p[0] = c_ast.Return(p[2] if len(p) == 4 else None, self._coord(p.lineno(1)))
+    
     def p_expression_statement(self, p):
-        """ expression_statement : expression_opt SEMI """
-        p[0] = p[1]
-    
-    def p_expression(self, p):
-        """ expression  : assignment_expression 
-                        | expression COMMA assignment_expression
-        """
-        if len(p) == 2:
-            p[0] = p[1]
-        else:
-            if not isinstance(p[1], c_ast.ExprList):
-                p[1] = c_ast.ExprList([p[1]], p[1].coord)
-            
-            p[1].exprs.append(p[3])
-            p[0] = p[1] 
-
-    def p_typedef_name(self, p):
-        """ typedef_name : TYPEID """
-        p[0] = p[1]
-
+        """ expression_statement : expression_opt SEMI """
+        p[0] = p[1]
+    
+    def p_expression(self, p):
+        """ expression  : assignment_expression 
+                        | expression COMMA assignment_expression
+        """
+        if len(p) == 2:
+            p[0] = p[1]
+        else:
+            if not isinstance(p[1], c_ast.ExprList):
+                p[1] = c_ast.ExprList([p[1]], p[1].coord)
+            
+            p[1].exprs.append(p[3])
+            p[0] = p[1] 
+
+    def p_typedef_name(self, p):
+        """ typedef_name : TYPEID """
+        p[0] = p[1]
+
     def p_assignment_expression(self, p):
-        """ assignment_expression   : conditional_expression
+        """ assignment_expression   : conditional_expression
                                     | unary_expression assignment_operator assignment_expression
-        """
-        if len(p) == 2:
-            p[0] = p[1]
-        else:
-            p[0] = c_ast.Assignment(p[2], p[1], p[3], p[1].coord)
-
-    # K&R2 defines these as many separate rules, to encode 
-    # precedence and associativity. Why work hard ? I'll just use
-    # the built in precedence/associativity specification feature
-    # of PLY. (see precedence declaration above)
-    #
+        """
+        if len(p) == 2:
+            p[0] = p[1]
+        else:
+            p[0] = c_ast.Assignment(p[2], p[1], p[3], p[1].coord)
+
+    # K&R2 defines these as many separate rules, to encode 
+    # precedence and associativity. Why work hard ? I'll just use
+    # the built in precedence/associativity specification feature
+    # of PLY. (see precedence declaration above)
+    #
     def p_assignment_operator(self, p):
-        """ assignment_operator : EQUALS
-                                | XOREQUAL   
-                                | TIMESEQUAL  
-                                | DIVEQUAL    
-                                | MODEQUAL    
-                                | PLUSEQUAL   
-                                | MINUSEQUAL  
-                                | LSHIFTEQUAL 
-                                | RSHIFTEQUAL 
-                                | ANDEQUAL    
+        """ assignment_operator : EQUALS
+                                | XOREQUAL   
+                                | TIMESEQUAL  
+                                | DIVEQUAL    
+                                | MODEQUAL    
+                                | PLUSEQUAL   
+                                | MINUSEQUAL  
+                                | LSHIFTEQUAL 
+                                | RSHIFTEQUAL 
+                                | ANDEQUAL    
                                 | OREQUAL     
-        """
-        p[0] = p[1]
-        
+        """
+        p[0] = p[1]
+        
     def p_constant_expression(self, p):
-        """ constant_expression : conditional_expression """
-        p[0] = p[1]
-    
+        """ constant_expression : conditional_expression """
+        p[0] = p[1]
+    
     def p_conditional_expression(self, p):
-        """ conditional_expression  : binary_expression
+        """ conditional_expression  : binary_expression
                                     | binary_expression CONDOP expression COLON conditional_expression
-        """
-        if len(p) == 2:
-            p[0] = p[1]
-        else:
-            p[0] = c_ast.TernaryOp(p[1], p[3], p[5], p[1].coord)
-    
+        """
+        if len(p) == 2:
+            p[0] = p[1]
+        else:
+            p[0] = c_ast.TernaryOp(p[1], p[3], p[5], p[1].coord)
+    
     def p_binary_expression(self, p):
-        """ binary_expression   : cast_expression
-                                | binary_expression TIMES binary_expression
-                                | binary_expression DIVIDE binary_expression
-                                | binary_expression MOD binary_expression
-                                | binary_expression PLUS binary_expression
-                                | binary_expression MINUS binary_expression
-                                | binary_expression RSHIFT binary_expression
-                                | binary_expression LSHIFT binary_expression
-                                | binary_expression LT binary_expression
-                                | binary_expression LE binary_expression
-                                | binary_expression GE binary_expression
-                                | binary_expression GT binary_expression
-                                | binary_expression EQ binary_expression
-                                | binary_expression NE binary_expression
-                                | binary_expression AND binary_expression
-                                | binary_expression OR binary_expression
-                                | binary_expression XOR binary_expression
-                                | binary_expression LAND binary_expression
+        """ binary_expression   : cast_expression
+                                | binary_expression TIMES binary_expression
+                                | binary_expression DIVIDE binary_expression
+                                | binary_expression MOD binary_expression
+                                | binary_expression PLUS binary_expression
+                                | binary_expression MINUS binary_expression
+                                | binary_expression RSHIFT binary_expression
+                                | binary_expression LSHIFT binary_expression
+                                | binary_expression LT binary_expression
+                                | binary_expression LE binary_expression
+                                | binary_expression GE binary_expression
+                                | binary_expression GT binary_expression
+                                | binary_expression EQ binary_expression
+                                | binary_expression NE binary_expression
+                                | binary_expression AND binary_expression
+                                | binary_expression OR binary_expression
+                                | binary_expression XOR binary_expression
+                                | binary_expression LAND binary_expression
                                 | binary_expression LOR binary_expression
-        """
-        if len(p) == 2:
-            p[0] = p[1]
-        else:
-            p[0] = c_ast.BinaryOp(p[2], p[1], p[3], p[1].coord)
-    
+        """
+        if len(p) == 2:
+            p[0] = p[1]
+        else:
+            p[0] = c_ast.BinaryOp(p[2], p[1], p[3], p[1].coord)
+    
     def p_cast_expression_1(self, p):
-        """ cast_expression : unary_expression """
-        p[0] = p[1]
-        
-    def p_cast_expression_2(self, p):
-        """ cast_expression : LPAREN type_name RPAREN cast_expression """
-        p[0] = c_ast.Cast(p[2], p[4], p[2].coord)
-    
+        """ cast_expression : unary_expression """
+        p[0] = p[1]
+        
+    def p_cast_expression_2(self, p):
+        """ cast_expression : LPAREN type_name RPAREN cast_expression """
+        p[0] = c_ast.Cast(p[2], p[4], p[2].coord)
+    
     def p_unary_expression_1(self, p):
-        """ unary_expression    : postfix_expression """
-        p[0] = p[1]
-    
+        """ unary_expression    : postfix_expression """
+        p[0] = p[1]
+    
     def p_unary_expression_2(self, p):
-        """ unary_expression    : PLUSPLUS unary_expression 
-                                | MINUSMINUS unary_expression
-                                | unary_operator cast_expression
-        """
-        p[0] = c_ast.UnaryOp(p[1], p[2], p[2].coord)
-    
-    def p_unary_expression_3(self, p):
-        """ unary_expression    : SIZEOF unary_expression 
-                                | SIZEOF LPAREN type_name RPAREN
-        """
-        p[0] = c_ast.UnaryOp(
-            p[1], 
-            p[2] if len(p) == 3 else p[3], 
-            self._coord(p.lineno(1)))
-    
+        """ unary_expression    : PLUSPLUS unary_expression 
+                                | MINUSMINUS unary_expression
+                                | unary_operator cast_expression
+        """
+        p[0] = c_ast.UnaryOp(p[1], p[2], p[2].coord)
+    
+    def p_unary_expression_3(self, p):
+        """ unary_expression    : SIZEOF unary_expression 
+                                | SIZEOF LPAREN type_name RPAREN
+        """
+        p[0] = c_ast.UnaryOp(
+            p[1], 
+            p[2] if len(p) == 3 else p[3], 
+            self._coord(p.lineno(1)))
+    
     def p_unary_operator(self, p):
-        """ unary_operator  : AND
-                            | TIMES
-                            | PLUS
-                            | MINUS
-                            | NOT
-                            | LNOT
-        """
-        p[0] = p[1]
-                                
+        """ unary_operator  : AND
+                            | TIMES
+                            | PLUS
+                            | MINUS
+                            | NOT
+                            | LNOT
+        """
+        p[0] = p[1]
+                                
     def p_postfix_exptession_1(self, p):
-        """ postfix_expression  : primary_expression """
-        p[0] = p[1]
-    
-    def p_postfix_exptession_2(self, p):
-        """ postfix_expression  : postfix_expression LBRACKET expression RBRACKET """
-        p[0] = c_ast.ArrayRef(p[1], p[3], p[1].coord)
-    
+        """ postfix_expression  : primary_expression """
+        p[0] = p[1]
+    
+    def p_postfix_exptession_2(self, p):
+        """ postfix_expression  : postfix_expression LBRACKET expression RBRACKET """
+        p[0] = c_ast.ArrayRef(p[1], p[3], p[1].coord)
+    
     def p_postfix_exptession_3(self, p):
-        """ postfix_expression  : postfix_expression LPAREN argument_expression_list RPAREN
+        """ postfix_expression  : postfix_expression LPAREN argument_expression_list RPAREN
                                 | postfix_expression LPAREN RPAREN
-        """
-        p[0] = c_ast.FuncCall(p[1], p[3] if len(p) == 5 else None, p[1].coord)
-    
+        """
+        p[0] = c_ast.FuncCall(p[1], p[3] if len(p) == 5 else None, p[1].coord)
+    
     def p_postfix_expression_4(self, p):
-        """ postfix_expression  : postfix_expression PERIOD identifier
-                                | postfix_expression ARROW identifier
-        """
-        p[0] = c_ast.StructRef(p[1], p[2], p[3], p[1].coord)
-
+        """ postfix_expression  : postfix_expression PERIOD identifier
+                                | postfix_expression ARROW identifier
+        """
+        p[0] = c_ast.StructRef(p[1], p[2], p[3], p[1].coord)
+
     def p_postfix_expression_5(self, p):
-        """ postfix_expression  : postfix_expression PLUSPLUS 
-                                | postfix_expression MINUSMINUS
-        """
-        p[0] = c_ast.UnaryOp('p' + p[2], p[1], p[1].coord)
-
+        """ postfix_expression  : postfix_expression PLUSPLUS 
+                                | postfix_expression MINUSMINUS
+        """
+        p[0] = c_ast.UnaryOp('p' + p[2], p[1], p[1].coord)
+
+# Ruyk
+    def p_postfix_exptession_6(self, p):
+        """ postfix_expression  : postfix_expression LKLAUNCH primary_expression COMMA primary_expression RKLAUNCH LPAREN argument_expression_list RPAREN
+                                | postfix_expression LKLAUNCH primary_expression COMMA primary_expression RKLAUNCH LPAREN  RPAREN
+
+        """
+        p[0] = c_ast.CUDAKernelCall(p[1], p[3], p[5], p[7] if len(p) == 7 else None, p[1].coord)
+
+
     def p_primary_expression_1(self, p):
-        """ primary_expression  : identifier """
-        p[0] = p[1]
-        
-    def p_primary_expression_2(self, p):
-        """ primary_expression  : constant """
-        p[0] = p[1]
-        
-    def p_primary_expression_3(self, p):
-        """ primary_expression  : STRING_LITERAL 
-                                | WSTRING_LITERAL
-        """
-        p[0] = c_ast.Constant(
-            'string', p[1], self._coord(p.lineno(1)))
-            
+        """ primary_expression  : identifier """
+        p[0] = p[1]
+        
+    def p_primary_expression_2(self, p):
+        """ primary_expression  : constant """
+        p[0] = p[1]
+        
+    def p_primary_expression_3(self, p):
+        """ primary_expression  : STRING_LITERAL 
+                                | WSTRING_LITERAL
+        """
+        p[0] = c_ast.Constant(
+            'string', p[1], self._coord(p.lineno(1)))
+            
     def p_primary_expression_4(self, p):
-        """ primary_expression  : LPAREN expression RPAREN """
-        p[0] = p[2]
-        
+        """ primary_expression  : LPAREN expression RPAREN """
+        p[0] = p[2]
+        
     def p_argument_expression_list(self, p):
-        """ argument_expression_list    : assignment_expression 
-                                        | argument_expression_list COMMA assignment_expression
-        """
-        if len(p) == 2: # single expr
-            p[0] = c_ast.ExprList([p[1]], p[1].coord)
-        else:
-            p[1].exprs.append(p[3])
-            p[0] = p[1]
-        
+        """ argument_expression_list    : assignment_expression 
+                                        | argument_expression_list COMMA assignment_expression
+        """
+        if len(p) == 2: # single expr
+            p[0] = c_ast.ExprList([p[1]], p[1].coord)
+        else:
+            p[1].exprs.append(p[3])
+            p[0] = p[1]
+        
     def p_identifier(self, p):
-        """ identifier  : ID """
-        p[0] = c_ast.ID(p[1], self._coord(p.lineno(1)))
-        
+        """ identifier  : ID """
+        p[0] = c_ast.ID(p[1], self._coord(p.lineno(1)))
+        
     def p_constant_1(self, p):
-        """ constant    : INT_CONST_DEC
-                        | INT_CONST_OCT
-                        | INT_CONST_HEX
-        """
-        p[0] = c_ast.Constant(
-            'int', p[1], self._coord(p.lineno(1)))
-            
-    def p_constant_2(self, p):
-        """ constant    : FLOAT_CONST """
-        p[0] = c_ast.Constant(
-            'float', p[1], self._coord(p.lineno(1)))
-    
+        """ constant    : INT_CONST_DEC
+                        | INT_CONST_OCT
+                        | INT_CONST_HEX
+        """
+        p[0] = c_ast.Constant(
+            'int', p[1], self._coord(p.lineno(1)))
+            
+    def p_constant_2(self, p):
+        """ constant    : FLOAT_CONST """
+        p[0] = c_ast.Constant(
+            'float', p[1], self._coord(p.lineno(1)))
+    
     def p_constant_3(self, p):
-        """ constant    : CHAR_CONST
-                        | WCHAR_CONST
-        """
-        p[0] = c_ast.Constant(
-            'char', p[1], self._coord(p.lineno(1)))
-        
-    def p_empty(self, p):
-        'empty : '
-        p[0] = None
-        
-    def p_error(self, p):
+        """ constant    : CHAR_CONST
+                        | WCHAR_CONST
+        """
+        p[0] = c_ast.Constant(
+            'char', p[1], self._coord(p.lineno(1)))
+        
+    def p_empty(self, p):
+        'empty : '
+        p[0] = None
+        
+    def p_error(self, p):
         if p:
-            self._parse_error(
-                'before: %s' % p.value, 
-                self._coord(p.lineno))
-        else:
-            self._parse_error('At end of input', '')
-
-
-if __name__ == "__main__":
-    import pprint
-    import time
-    
+            self._parse_error(
+                'before: %s' % p.value, 
+                self._coord(p.lineno))
+        else:
+            self._parse_error('At end of input', '')
+
+
+if __name__ == "__main__":
+    import pprint
+    import time
+    
     t1 = time.time()
-    parser = CParser(lex_optimize=True, yacc_debug=True, yacc_optimize=False)
-    print time.time() - t1
-    
-    buf = ''' 
-        int (*k)(int);
-    '''
-    
-    # set debuglevel to 2 for debugging
-    t = parser.parse(buf, 'x.c', debuglevel=0)
-    t.show(showcoord=True)
+    parser = CParser(lex_optimize=True, yacc_debug=True, yacc_optimize=False)
+    print time.time() - t1
+    
+    buf = ''' 
+        int (*k)(int);
+    '''
+    
+    # set debuglevel to 2 for debugging
+    t = parser.parse(buf, 'x.c', debuglevel=0)
+    t.show(showcoord=True)
Index: pycparser/__init__.py
===================================================================
--- pycparser/__init__.py	(revision 88)
+++ pycparser/__init__.py	(working copy)
@@ -1,75 +1,75 @@
-#-----------------------------------------------------------------
-# pycparser: __init__.py
-#
-# This package file exports some convenience functions for 
-# interacting with pycparser
-#
-# Copyright (C) 2008-2009, Eli Bendersky
-# License: LGPL
-#-----------------------------------------------------------------
-
-__all__ = ['c_lexer', 'c_parser', 'c_ast']
-__version__ = '1.05'
-
-from subprocess import Popen, PIPE
-from types import ListType
-
-from c_parser import CParser
-
-
-def parse_file( filename, use_cpp=False, 
-                cpp_path='cpp', cpp_args=''):
-    """ Parse a C file using pycparser.
-    
-        filename:
-            Name of the file you want to parse.
-        
-        use_cpp:
-            Set to True if you want to execute the C pre-processor
-            on the file prior to parsing it.
-        
-        cpp_path:
-            If use_cpp is True, this is the path to 'cpp' on your
-            system. If no path is provided, it attempts to just
-            execute 'cpp', so it must be in your PATH.
-        
-        cpp_args:
-            If use_cpp is True, set this to the command line 
-            arguments strings to cpp. Be careful with quotes - 
-            it's best to pass a raw string (r'') here. 
-            For example:
-            r'-I../utils/fake_libc_include'
-            If several arguments are required, pass a list of 
-            strings.
-        
-        When successful, an AST is returned. ParseError can be 
-        thrown if the file doesn't parse successfully.
-        
+#-----------------------------------------------------------------
+# pycparser: __init__.py
+#
+# This package file exports some convenience functions for 
+# interacting with pycparser
+#
+# Copyright (C) 2008-2009, Eli Bendersky
+# License: LGPL
+#-----------------------------------------------------------------
+
+__all__ = ['c_lexer', 'c_parser', 'c_ast']
+__version__ = '1.05'
+
+from subprocess import Popen, PIPE
+from types import ListType
+
+from c_parser import CParser
+
+
+def parse_file( filename, use_cpp=False, 
+                cpp_path='cpp', cpp_args=''):
+    """ Parse a C file using pycparser.
+    
+        filename:
+            Name of the file you want to parse.
+        
+        use_cpp:
+            Set to True if you want to execute the C pre-processor
+            on the file prior to parsing it.
+        
+        cpp_path:
+            If use_cpp is True, this is the path to 'cpp' on your
+            system. If no path is provided, it attempts to just
+            execute 'cpp', so it must be in your PATH.
+        
+        cpp_args:
+            If use_cpp is True, set this to the command line 
+            arguments strings to cpp. Be careful with quotes - 
+            it's best to pass a raw string (r'') here. 
+            For example:
+            r'-I../utils/fake_libc_include'
+            If several arguments are required, pass a list of 
+            strings.
+        
+        When successful, an AST is returned. ParseError can be 
+        thrown if the file doesn't parse successfully.
+        
         Errors from cpp will be printed out. 
-    """
-    if use_cpp:   
-        path_list = [cpp_path]
-        if isinstance(cpp_args, ListType):
-            path_list += cpp_args
-        elif cpp_args != '': 
-            path_list += [cpp_args]
-        path_list += [filename]
-        
-        # Note the use of universal_newlines to treat all newlines
-        # as \n for Python's purpose
-        #
-        pipe = Popen(   path_list, 
-                        stdout=PIPE, 
-                        universal_newlines=True)
-        text = pipe.communicate()[0]
-    else:
-        text = open(filename).read()
-    
-    parser = CParser()
-    return parser.parse(text, filename)
-    
-
-if __name__ == "__main__":
-    pass
+    """
+    if use_cpp:   
+        path_list = [cpp_path]
+        if isinstance(cpp_args, ListType):
+            path_list += cpp_args
+        elif cpp_args != '': 
+            path_list += [cpp_args]
+        path_list += [filename]
+        
+        # Note the use of universal_newlines to treat all newlines
+        # as \n for Python's purpose
+        #
+        pipe = Popen(   path_list, 
+                        stdout=PIPE, 
+                        universal_newlines=True)
+        text = pipe.communicate()[0]
+    else:
+        text = open(filename).read()
     
-
+    parser = CParser(lex_optimize=False,yacc_optimize=False,yacc_debug=False)
+    return parser.parse(text, filename)
+    
+
+if __name__ == "__main__":
+    pass
+    
+
Index: pycparser/_ast_gen.py
===================================================================
--- pycparser/_ast_gen.py	(revision 88)
+++ pycparser/_ast_gen.py	(working copy)
@@ -1,249 +1,249 @@
-#-----------------------------------------------------------------
-# _ast_gen.py
-#
-# Generates the AST Node classes from a specification given in 
-# a .yaml file
-#
-# The design of this module was inspired by astgen.py from the
-# Python 2.5 code-base.
-#
-# Copyright (C) 2008-2009, Eli Bendersky
-# License: LGPL
-#-----------------------------------------------------------------
-
-import pprint
-from string import Template
-
-import yaml
-
-
+#-----------------------------------------------------------------
+# _ast_gen.py
+#
+# Generates the AST Node classes from a specification given in 
+# a .yaml file
+#
+# The design of this module was inspired by astgen.py from the
+# Python 2.5 code-base.
+#
+# Copyright (C) 2008-2009, Eli Bendersky
+# License: LGPL
+#-----------------------------------------------------------------
+
+import pprint
+from string import Template
+
+import yaml
+
+
 class ASTCodeGenerator(object):
-    def __init__(self, cfg_filename='_c_ast.yaml'):
-        """ Initialize the code generator from a configuration
+    def __init__(self, cfg_filename='_c_ast.yaml'):
+        """ Initialize the code generator from a configuration
             file.
-        """
-        self.cfg_filename = cfg_filename
-        cfg = yaml.load(open(cfg_filename).read())
-        self.node_cfg = [NodeCfg(name, cfg[name]) for name in cfg]
-
-        #~ pprint.pprint(self.node_cfg)
-        #~ print ''
-
-    def generate(self, file=None):
-        """ Generates the code into file, an open file buffer.
-        """
-        src = Template(_PROLOGUE_COMMENT).substitute(
-            cfg_filename=self.cfg_filename)
-        
-        src += _PROLOGUE_CODE
-        for node_cfg in self.node_cfg:
-            src += node_cfg.generate_source() + '\n\n'
-        
+        """
+        self.cfg_filename = cfg_filename
+        cfg = yaml.load(open(cfg_filename).read())
+        self.node_cfg = [NodeCfg(name, cfg[name]) for name in cfg]
+
+        #~ pprint.pprint(self.node_cfg)
+        #~ print ''
+
+    def generate(self, file=None):
+        """ Generates the code into file, an open file buffer.
+        """
+        src = Template(_PROLOGUE_COMMENT).substitute(
+            cfg_filename=self.cfg_filename)
+        
+        src += _PROLOGUE_CODE
+        for node_cfg in self.node_cfg:
+            src += node_cfg.generate_source() + '\n\n'
+        
         file.write(src)
-
-
+
+
 class NodeCfg(object):
-    def __init__(self, name, contents):
-        self.name = name
-        self.all_entries = []
-        self.attr = []
-        self.child = []
-        self.seq_child = []
-        
-        for entry in contents:
-            clean_entry = entry.rstrip('*')
-            self.all_entries.append(clean_entry)
-            
-            if entry.endswith('**'):
-                self.seq_child.append(clean_entry)
-            elif entry.endswith('*'):
-                self.child.append(clean_entry)
-            else:
+    def __init__(self, name, contents):
+        self.name = name
+        self.all_entries = []
+        self.attr = []
+        self.child = []
+        self.seq_child = []
+        
+        for entry in contents:
+            clean_entry = entry.rstrip('*')
+            self.all_entries.append(clean_entry)
+            
+            if entry.endswith('**'):
+                self.seq_child.append(clean_entry)
+            elif entry.endswith('*'):
+                self.child.append(clean_entry)
+            else:
                 self.attr.append(entry)
-
+
     def generate_source(self):
-        src = self._gen_init()
-        src += '\n' + self._gen_children()
-        src += '\n' + self._gen_show()
-        return src
-    
+        src = self._gen_init()
+        src += '\n' + self._gen_children()
+        src += '\n' + self._gen_show()
+        return src
+    
     def _gen_init(self):
-        src = "class %s(Node):\n" % self.name
-
-        if self.all_entries:
-            args = ', '.join(self.all_entries)
-            arglist = '(self, %s, coord=None)' % args
-        else:
-            arglist = '(self, coord=None)'
-        
-        src += "    def __init__%s:\n" % arglist
-        
-        for name in self.all_entries + ['coord']:
-            src += "        self.%s = %s\n" % (name, name)
-        
-        return src
-    
+        src = "class %s(Node):\n" % self.name
+
+        if self.all_entries:
+            args = ', '.join(self.all_entries)
+            arglist = '(self, %s, coord=None)' % args
+        else:
+            arglist = '(self, coord=None)'
+        
+        src += "    def __init__%s:\n" % arglist
+        
+        for name in self.all_entries + ['coord']:
+            src += "        self.%s = %s\n" % (name, name)
+        
+        return src
+    
     def _gen_children(self):
-        src = '    def children(self):\n'
-        
-        if self.all_entries:
-            src += '        nodelist = []\n'
-            
-            template = ('' +
-                '        if self.%s is not None:' +
-                ' nodelist.%s(self.%s)\n')
-            
-            for child in self.child:
-                src += template % (
-                    child, 'append', child)
-            
-            for seq_child in self.seq_child:
-                src += template % (
-                    seq_child, 'extend', seq_child)
-                    
-            src += '        return tuple(nodelist)\n'
-        else:
-            src += '        return ()\n'
-            
-        return src
-
+        src = '    def children(self):\n'
+        
+        if self.all_entries:
+            src += '        nodelist = []\n'
+            
+            template = ('' +
+                '        if self.%s is not None:' +
+                ' nodelist.%s(self.%s)\n')
+            
+            for child in self.child:
+                src += template % (
+                    child, 'append', child)
+            
+            for seq_child in self.seq_child:
+                src += template % (
+                    seq_child, 'extend', seq_child)
+                    
+            src += '        return tuple(nodelist)\n'
+        else:
+            src += '        return ()\n'
+            
+        return src
+
     def _gen_show(self):
-        src = '    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):\n'
-        src += "        lead = ' ' * offset\n"
-        
-        src += "        buf.write(lead + '%s: ')\n\n" % self.name
-        
-        if self.attr:
-            src += "        if attrnames:\n"
-            src += "            attrstr = ', '.join('%s=%s' % nv for nv in ["
-            src += ', '.join('("%s", repr(%s))' % (nv, 'self.%s' % nv) for nv in self.attr)
-            src += '])\n'
-            src += "        else:\n"
-            src += "            attrstr = ', '.join('%s' % v for v in ["
-            src += ', '.join('self.%s' % v for v in self.attr)
-            src += '])\n'
-            src += "        buf.write(attrstr)\n\n"
-        
-        src += "        if showcoord:\n"
-        src += "            buf.write(' (at %s)' % self.coord)\n"
-        src += "        buf.write('\\n')\n\n"
-        
-        src += "        for c in self.children():\n"
-        src += "            c.show(buf, offset + 2, attrnames, showcoord)\n"
-        
-        return src
-
-
-_PROLOGUE_COMMENT = \
-r'''#-----------------------------------------------------------------
-# ** ATTENTION **
-# This code was automatically generated from the file:
-# $cfg_filename 
-#
-# Do not modify it directly. Modify the configuration file and
-# run the generator again.
-# ** ** *** ** **
-#
-# pycparser: c_ast.py
-#
-# AST Node classes.
-#
-# Copyright (C) 2008, Eli Bendersky
-# License: LGPL
-#-----------------------------------------------------------------
-
-'''
-
-_PROLOGUE_CODE = r'''
-import sys
-
-
-class Node(object):
-    """ Abstract base class for AST nodes.
-    """
-    def children(self):
-        """ A sequence of all children that are Nodes
-        """
-        pass
-
-    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
-        """ Pretty print the Node and all its attributes and
-            children (recursively) to a buffer.
-            
-            file:   
-                Open IO buffer into which the Node is printed.
-            
-            offset: 
-                Initial offset (amount of leading spaces) 
-            
-            attrnames:
-                True if you want to see the attribute names in
-                name=value pairs. False to only see the values.
-            
-            showcoord:
-                Do you want the coordinates of each Node to be
-                displayed.
-        """
-        pass
-
-
-class NodeVisitor(object):
-    """ A base NodeVisitor class for visiting c_ast nodes. 
-        Subclass it and define your own visit_XXX methods, where
-        XXX is the class name you want to visit with these 
-        methods.
-        
-        For example:
-        
-        class ConstantVisitor(NodeVisitor):
-            def __init__(self):
-                self.values = []
-            
-            def visit_Constant(self, node):
-                self.values.append(node.value)
-
-        Creates a list of values of all the constant nodes 
-        encountered below the given node. To use it:
-        
-        cv = ConstantVisitor()
-        cv.visit(node)
-        
-        Notes:
-        
-        *   generic_visit() will be called for AST nodes for which 
-            no visit_XXX method was defined. 
-        *   The children of nodes for which a visit_XXX was 
-            defined will not be visited - if you need this, call
-            generic_visit() on the node. 
-            You can use:
-                NodeVisitor.generic_visit(self, node)
-        *   Modeled after Python's own AST visiting facilities
-            (the ast module of Python 3.0)
-    """
-    def visit(self, node):
-        """ Visit a node. 
-        """
-        method = 'visit_' + node.__class__.__name__
-        visitor = getattr(self, method, self.generic_visit)
-        return visitor(node)
-        
-    def generic_visit(self, node):
-        """ Called if no explicit visitor function exists for a 
-            node. Implements preorder visiting of the node.
-        """
-        for c in node.children():
-            self.visit(c)
-
-
-'''
-
-
-
-if __name__ == "__main__":
-    import sys
+        src = '    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):\n'
+        src += "        lead = ' ' * offset\n"
+        
+        src += "        buf.write(lead + '%s: ')\n\n" % self.name
+        
+        if self.attr:
+            src += "        if attrnames:\n"
+            src += "            attrstr = ', '.join('%s=%s' % nv for nv in ["
+            src += ', '.join('("%s", repr(%s))' % (nv, 'self.%s' % nv) for nv in self.attr)
+            src += '])\n'
+            src += "        else:\n"
+            src += "            attrstr = ', '.join('%s' % v for v in ["
+            src += ', '.join('self.%s' % v for v in self.attr)
+            src += '])\n'
+            src += "        buf.write(attrstr)\n\n"
+        
+        src += "        if showcoord:\n"
+        src += "            buf.write(' (at %s)' % self.coord)\n"
+        src += "        buf.write('\\n')\n\n"
+        
+        src += "        for c in self.children():\n"
+        src += "            c.show(buf, offset + 2, attrnames, showcoord)\n"
+        
+        return src
+
+
+_PROLOGUE_COMMENT = \
+r'''#-----------------------------------------------------------------
+# ** ATTENTION **
+# This code was automatically generated from the file:
+# $cfg_filename 
+#
+# Do not modify it directly. Modify the configuration file and
+# run the generator again.
+# ** ** *** ** **
+#
+# pycparser: c_ast.py
+#
+# AST Node classes.
+#
+# Copyright (C) 2008, Eli Bendersky
+# License: LGPL
+#-----------------------------------------------------------------
+
+'''
+
+_PROLOGUE_CODE = r'''
+import sys
+
+
+class Node(object):
+    """ Abstract base class for AST nodes.
+    """
+    def children(self):
+        """ A sequence of all children that are Nodes
+        """
+        pass
+
+    def show(self, buf=sys.stdout, offset=0, attrnames=False, showcoord=False):
+        """ Pretty print the Node and all its attributes and
+            children (recursively) to a buffer.
+            
+            file:   
+                Open IO buffer into which the Node is printed.
+            
+            offset: 
+                Initial offset (amount of leading spaces) 
+            
+            attrnames:
+                True if you want to see the attribute names in
+                name=value pairs. False to only see the values.
+            
+            showcoord:
+                Do you want the coordinates of each Node to be
+                displayed.
+        """
+        pass
+
+
+class NodeVisitor(object):
+    """ A base NodeVisitor class for visiting c_ast nodes. 
+        Subclass it and define your own visit_XXX methods, where
+        XXX is the class name you want to visit with these 
+        methods.
+        
+        For example:
+        
+        class ConstantVisitor(NodeVisitor):
+            def __init__(self):
+                self.values = []
+            
+            def visit_Constant(self, node):
+                self.values.append(node.value)
+
+        Creates a list of values of all the constant nodes 
+        encountered below the given node. To use it:
+        
+        cv = ConstantVisitor()
+        cv.visit(node)
+        
+        Notes:
+        
+        *   generic_visit() will be called for AST nodes for which 
+            no visit_XXX method was defined. 
+        *   The children of nodes for which a visit_XXX was 
+            defined will not be visited - if you need this, call
+            generic_visit() on the node. 
+            You can use:
+                NodeVisitor.generic_visit(self, node)
+        *   Modeled after Python's own AST visiting facilities
+            (the ast module of Python 3.0)
+    """
+    def visit(self, node):
+        """ Visit a node. 
+        """
+        method = 'visit_' + node.__class__.__name__
+        visitor = getattr(self, method, self.generic_visit)
+        return visitor(node)
+        
+    def generic_visit(self, node):
+        """ Called if no explicit visitor function exists for a 
+            node. Implements preorder visiting of the node.
+        """
+        for c in node.children():
+            self.visit(c)
+
+
+'''
+
+
+
+if __name__ == "__main__":
+    import sys
     
-    ast_gen = ASTCodeGenerator('_c_ast.yaml')
-    ast_gen.generate(open('c_ast.py', 'w'))
-    
-    
-    
+    ast_gen = ASTCodeGenerator('_c_ast.yaml')
+    ast_gen.generate(open('c_ast.py', 'w'))
+    
+    
+    
Index: pycparser/c_lexer.py
===================================================================
--- pycparser/c_lexer.py	(revision 88)
+++ pycparser/c_lexer.py	(working copy)
@@ -157,6 +157,12 @@
         
         # pre-processor 
         'PPHASH',      # '#'
+
+	####################
+	# Ruyk
+	'PRAGMA', # pragma
+	'OMP', # openmp
+   'LKLAUNCH', 'RKLAUNCH' # CUDA kernel launch
     )
 
     ##
@@ -223,7 +229,22 @@
         else:
             t.type = 'PPHASH'
             return t
-    
+
+    ####################
+    # Ruyk
+    def t_PRAGMA(self, t):
+        r'pragma'
+	print " PRAGMA TOKEN "
+        t.type = 'PRAGMA'
+        return t
+
+    def t_OMP(self, t):
+        r'omp'
+	print " OPENMP TOKEN "
+        t.type = 'OMP'
+        return t
+
+
     ##
     ## Rules for the ppline state
     ##
@@ -298,7 +319,12 @@
     t_GE                = r'>='
     t_EQ                = r'=='
     t_NE                = r'!='
+    # *** Ruyk
+    # CUDA kernel launch
+    t_LKLAUNCH            = r'<<<'
+    t_RKLAUNCH            = r'>>>'
 
+
     # Assignment operators
     t_EQUALS            = r'='
     t_TIMESEQUAL        = r'\*='
@@ -337,7 +363,7 @@
 
     t_STRING_LITERAL    = string_literal
     
-    # The following floating and integer constants are defined as 
+#    # The following floating and integer constants are defined as 
     # functions to impose a strict order (otherwise, decimal
     # is placed before the others because its regex is longer,
     # and this is bad)
@@ -410,7 +436,8 @@
 
 
 if __name__ == "__main__":
-    filename = '../zp.c'
+#    filename = '../z_test.c'
+    filename = '../examples/c_files/funky.c'
     text = open(filename).read()
     
     #~ text = '"'+r"""ka \p ka"""+'"'
Index: pycparser/_c_ast.yaml
===================================================================
--- pycparser/_c_ast.yaml	(revision 88)
+++ pycparser/_c_ast.yaml	(working copy)
@@ -92,6 +92,14 @@
 #
 FuncCall: [name*, args*]
 
+
+# name: CUDA Kernel Lunch
+# args: <<< grid, block >>> ExprList
+#
+# Ruyk
+CUDAKernelCall: [name*, grid*, block*, args*]
+
+
 # type <decl>(args)
 #
 FuncDecl: [args*, type*]
@@ -161,4 +169,8 @@
 While: [cond*, stmt*]
 
 
+####################
+# Ruyk
+Pragma: [name]
 
+Omp: [name]
Index: examples/c_files/funky.c
===================================================================
--- examples/c_files/funky.c	(revision 88)
+++ examples/c_files/funky.c	(working copy)
@@ -1,3 +1,4 @@
+
 char foo(void)
 {
     return '1';
Index: examples/using_cpp_libc.py
===================================================================
--- examples/using_cpp_libc.py	(revision 88)
+++ examples/using_cpp_libc.py	(working copy)
@@ -25,8 +25,8 @@
         filename = 'c_files/year.c'
 
     ast = parse_file(filename, use_cpp=True,
-            cpp_path='../utils/cpp.exe', 
-            cpp_args=r'-I../utils/fake_libc_include')
+            cpp_path='cpp', 
+            cpp_args=r'-ansi -pedantic -U __USE_GNU -I../utils/fake_libc_include')
     
     ast.show()
 
